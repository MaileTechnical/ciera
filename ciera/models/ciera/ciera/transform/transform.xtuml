-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'transform',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("a442477a-0195-4034-8986-e4129bb601d0",
	112,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'ciera::ciera::transform');
INSERT INTO DIM_DIA
	VALUES ("a442477a-0195-4034-8986-e4129bb601d0",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	"00000000-0000-0000-0000-000000000000",
	'transformApplication',
	'',
	'root_package = param.root_package;
select one s_sys related by root_package->S_SYS[R1405];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_sys.Name, start_lower:false ) + "Application";
file.path = T::l( s:T::r( s:s_sys.Name ) );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the application object
create object instance app of Application;
relate app to file across R401;

// create application executors
index = 0;
while ( index < 1 ) // single executor for now
  create object instance executor of ApplicationExecutor;
  executor.index = index;
  relate executor to app across R4027.''executes tasks for'';
  index = index + 1;
end while;

// create the import block
::addStringToImports( file:file, s:"io.ciera.cairn.application.ApplicationExecutor", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.cairn.application.tasks.GenericExecutionTask", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.application.IApplication", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.application.IRunContext", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.components.IComponent", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );

// translate components definitions
select many c_cs related by root_package->PE_PE[R8000]->C_C[R8001];
select many cl_ics related by root_package->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
c_cs = c_cs | cl_ics;
select any empty_comp_def from instances of ComponentDefinition where false;
select any current_comp_inst from instances of ComponentInstantiation where false;
for each c_c in c_cs
  select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  if ( empty comp_def )
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:1 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:2 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:3 );
    select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  end if;
  create object instance comp_inst of ComponentInstantiation;
  relate  comp_def to app across R426 using comp_inst;
  select one comp_def_file related by comp_def->File[R401];
  ::addFileToImports( file:file, file_to_import:comp_def_file, type:ImportType::IMPL );
  select any executor from instances of ApplicationExecutor where ( selected.index == 0 );  // single executor for now
  relate executor to comp_inst across R4028.''provides execution context for'';
  if ( not_empty current_comp_inst )
    relate comp_inst to current_comp_inst across R4029.''follows'';
    comp_inst.index = current_comp_inst.index + 1;
  else
    comp_inst.index = 0;
  end if;
  current_comp_inst = comp_inst;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("6b6c262c-3690-4123-b000-38fb9cc04e80",
	"86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	'root_package',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO S_SPARM
	VALUES ("3f6c7555-b604-4d78-a329-f859ff004ed4",
	"86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6b6c262c-3690-4123-b000-38fb9cc04e80",
	'');
INSERT INTO PE_PE
	VALUES ("86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	"00000000-0000-0000-0000-000000000000",
	'transformComponentDefinition',
	'',
	'c_c = param.c_c;
containing_comp_def = param.containing_comp_def;

if ( 1 == param.pass )

  // create the file
  create object instance file of File;
  file.name = ::camelCaseName( name:c_c.Name, start_lower:false );
  file.path = param.path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the component definition object
  create object instance comp_def of ComponentDefinition;
  relate comp_def to file across R401;
  comp_def.extends = "Component<" + comp_def.name + ">";
  relate c_c to comp_def across R4573.''is basis for'';

  // transform ports
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    ::transformPort( c_po:c_po, comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ) );
  end for;

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:param.pass );
  end for;

  // transform inner components
  select many inner_c_cs related by c_c->PE_PE[R8003]->C_C[R8001];
  for each inner_c_c in inner_c_cs
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:1 );
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:2 );
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:3 );
  end for;

  // transform instance population selectors
  select many objs related by comp_def->Class[R408.''maintains instances of''];
  for each obj in objs
    create object instance inst_pop_selector of InstancePopulationSelector;
    inst_pop_selector.name = obj.name + "_instances";
    relate inst_pop_selector to comp_def across R447.''selects instances out of population of'';
    relate inst_pop_selector to obj across R449.''selects instances of'';
  end for;

  // create import block
  ::addStringToImports( file:file, s:"io.ciera.cairn.components.Component", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.application.IRunContext", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IModelInstance", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );

elif ( 2 == param.pass )

  select any file from instances of File where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) and selected.package == ::pathToPackage( path:param.path ) );
  select one comp_def related by file->ComponentDefinition[R401];

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:param.pass );
  end for;

else

  select any file from instances of File where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) and selected.package == ::pathToPackage( path:param.path ) );
  select one comp_def related by file->ComponentDefinition[R401];

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::l( s:c_c.Name ), pass:param.pass );
  end for;

  // transform relationship population selectors
  select many rels related by comp_def->Relationship[R448.''maintains instances of''];
  for each rel in rels
    create object instance rel_pop_selector of RelationshipPopulationSelector;
    rel_pop_selector.name = rel.name + "s";
    relate rel_pop_selector to comp_def across R4571.''selects relationships out of population of'';
    relate rel_pop_selector to rel across R4572.''selects instances of'';
  end for;
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9e250ca1-996f-471c-9f10-bb5ad2591f03",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("35145c47-5490-4738-a0b2-7e513f9ed71c",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"9e250ca1-996f-471c-9f10-bb5ad2591f03",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO S_SPARM
	VALUES ("339de843-5314-4e62-a1ea-25f8e95de699",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"35145c47-5490-4738-a0b2-7e513f9ed71c",
	'');
INSERT INTO S_SPARM
	VALUES ("066e5021-8977-4091-b68e-2a3948e3cf46",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"339de843-5314-4e62-a1ea-25f8e95de699",
	'');
INSERT INTO PE_PE
	VALUES ("a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c26da85-1e78-4183-88ca-60811dc084db",
	"00000000-0000-0000-0000-000000000000",
	'transformPackage',
	'',
	'ep_pkg = param.ep_pkg;
path = param.path;

if ( 1 == param.pass )

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform functions
  select many s_syncs related by pe_pes->S_SYNC[R8001];
  for each s_sync in s_syncs
    ::transformFunction( s_sync:s_sync, comp_def:containing_comp_def );
  end for;

  // transform constants

  // transform datatypes
  select many edts related by pe_pes->S_DT[R8001]->S_EDT[R17]->S_DT[R17];
  for each edt in edts
    ::transformEnumeratedType( s_dt:edt );
  end for;
  
  select many udts related by pe_pes->S_DT[R8001]->S_UDT[R17]->S_DT[R17];
  for each udt in udts
    ::transformUserDefinedType( s_dt:udt );
  end for;

  // transform EEs
  select many s_ees related by pe_pes->S_EE[R8001];
  for each s_ee in s_ees
    ::transformUtility( s_ee:s_ee, ep_pkg:ep_pkg, containing_comp_def:containing_comp_def, exclude:false, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ) );
  end for;

  // transform classes
  select many o_objs related by pe_pes->O_OBJ[R8001];
  for each o_obj in o_objs
    ::transformClass( o_obj:o_obj, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ) );
  end for;

  // transform components
  select many c_cs related by pe_pes->C_C[R8001];
  for each c_c in c_cs
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:1 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:2 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:3 );
  end for;

  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:param.pass );
  end for;

elif ( 2 == param.pass )

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform associations
  select many r_rels related by pe_pes->R_REL[R8001];
  for each r_rel in r_rels
    ::transformAssociation( r_rel:r_rel, containing_comp_def:containing_comp_def );
  end for;

  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:param.pass );
  end for;
  
else

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform selectors
  select many o_objs related by pe_pes->O_OBJ[R8001];
  select many objs related by o_objs->Class[R409.''is basis for''];
  for each obj in objs
    ::transformSelectors( obj:obj );
  end for;

  // transform attribute references
  select many o_objs related by pe_pes->O_OBJ[R8001];
  select many objs related by o_objs->Class[R409.''is basis for''];
  for each obj in objs
    ::transformAttributeReferences( obj:obj );
  end for;

  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::l( s:T::r( s:ep_pkg.Name ) ), pass:param.pass );
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e05335a1-ada2-43dd-bdb1-f29837aff1fc",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0ca0ea7b-7e27-4164-8c8f-51956eba948a",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"e05335a1-ada2-43dd-bdb1-f29837aff1fc",
	'');
INSERT INTO S_SPARM
	VALUES ("4787f035-98e2-4c37-bf7d-99b5f69be179",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0ca0ea7b-7e27-4164-8c8f-51956eba948a",
	'');
INSERT INTO S_SPARM
	VALUES ("62e875fa-2c95-46e0-a336-810edead7d02",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"4787f035-98e2-4c37-bf7d-99b5f69be179",
	'');
INSERT INTO PE_PE
	VALUES ("1c26da85-1e78-4183-88ca-60811dc084db",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4372e9ec-b226-4bdc-9219-9427ca71b423",
	"00000000-0000-0000-0000-000000000000",
	'transformFunction',
	'',
	's_sync = param.s_sync;
comp_def = param.comp_def;

// create function object
create object instance func of Function;
relate func to comp_def across R405;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_sync.Name;
invocable.parent_name = comp_def.name;
invocable.parent_package = comp_def.package;
relate func to invocable across R427;
invocable.oal = s_sync.Action_Semantics_internal;

// link type
select one s_dt related by s_sync->S_DT[R25];
select many s_dims related by s_sync->S_DIM[R51];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any s_sparm related by s_sync->S_SPARM[R24];
prev_s_sparm = s_sparm;
// select first parameter
while ( not_empty prev_s_sparm )
  s_sparm = prev_s_sparm;
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
end while;
while ( not_empty s_sparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_sparm.Name;
  parm.by_ref = ( 1 == s_sparm.By_Ref );
  select one parm_dt related by s_sparm->S_DT[R26];
  select many s_dims related by s_sparm->S_DIM[R52];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
end while;

// see if this is an initializer function
select one c_c related by comp_def->C_C[R4573.''is transformed from''];
select one c_c_pe related by c_c->PE_PE[R8001];
select any init_function_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                             selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                             selected.feature_name == "InitFunction" );
if ( not_empty init_function_mark and func.name == init_function_mark.value )
  select any s_sparm related by s_sync->S_SPARM[R24];
  if ( empty s_sparm )
    select one init_function related by comp_def->Function[R4561.''initialized by''];
    if ( empty init_function )
      relate func to comp_def across R4561.''initializes'';
    else
      // TODO bad
    end if;
  else
    // TODO bad
  end if;
end if;

// relate the body
select one act_act related by s_sync->ACT_FNB[R695]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432.''actions transformed from'';
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("20dcc580-c900-4c37-9db9-c96b57ce0c7a",
	"4372e9ec-b226-4bdc-9219-9427ca71b423",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("30cff3bd-5277-4221-8d57-b94d725a461b",
	"4372e9ec-b226-4bdc-9219-9427ca71b423",
	'comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"20dcc580-c900-4c37-9db9-c96b57ce0c7a",
	'');
INSERT INTO PE_PE
	VALUES ("4372e9ec-b226-4bdc-9219-9427ca71b423",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("26bcd5a8-82fd-48ba-8dfc-40a65ebfd881",
	"00000000-0000-0000-0000-000000000000",
	'transformBuiltinTypes',
	'',
	'select many s_dts from instances of S_DT;
for each s_dt in s_dts

  if ( ::s_dtIsBuiltin( s_dt:s_dt ) )

    type_name = "";
    type_package = "";
    type_primitive = false;
    type_unique = false;
    type_inst = false;
    type_instset = false;
    type_default_value = "";
    if ( "boolean" == s_dt.Name )
      type_name = "boolean";
      type_primitive = true;
      type_default_value = "false";
    elif ( "component_ref" == s_dt.Name )
      type_name = "IComponent";
      type_package = "io.ciera.summit.components";
      type_default_value = "null";
    elif ( "date" == s_dt.Name )
      type_name = "Date";
      type_package = "io.ciera.summit.time";
      type_default_value = "null";
    elif ( "inst<Event>" == s_dt.Name )
      type_name = "IEvent";
      type_package = "io.ciera.summit.statemachine";
      type_default_value = "null";
    elif ( "inst_ref<Timer>" == s_dt.Name )
      type_name = "Timer";
      type_package = "io.ciera.summit.time";
      type_default_value = "null";
    elif ( "integer" == s_dt.Name )
      type_name = "int";
      type_primitive = true;
      type_default_value = "0";
    elif ( "real" == s_dt.Name )
      type_name = "double";
      type_primitive = true;
      type_default_value = "0d";
    elif ( "string" == s_dt.Name )
      type_name = "XtumlString";
      type_package = "io.ciera.summit.types";
      type_default_value = "new XtumlString( " + STR::quote() + STR::quote() + " )";
    elif ( "timestamp" == s_dt.Name )
      type_name = "TimeStamp";
      type_package = "io.ciera.summit.types";
      type_default_value = "null";
    elif ( "unique_id" == s_dt.Name )
      type_name = "UniqueId";
      type_package = "io.ciera.summit.types";
      type_unique = true;
      type_default_value = "new UniqueId()";
    elif ( "void" == s_dt.Name )
      type_name = "void";
      type_primitive = true;
      type_default_value = "";
    elif ( "inst_ref_set<Object>" == s_dt.Name )
      type_name = "IInstanceSet";
      type_package = "io.ciera.summit.classes";
      type_instset = true;
      type_default_value = "null";
    elif ( "inst_ref<Object>" == s_dt.Name )
      type_name = "IModelInstance";
      type_package = "io.ciera.summit.classes";
      type_inst = true;
      type_default_value = "null";
    elif ( "inst_ref<Mapping>" == s_dt.Name ) // TODO
      type_name = "InstRefMapping";
      type_package = "io.ciera.summit.types";
      type_default_value = "null";
    elif ( "inst<Mapping>" == s_dt.Name ) // TODO
      type_name = "InstMapping";
      type_package = "io.ciera.summit.types";
      type_default_value = "null";
    end if;

    if ( "" != type_name )
      create object instance type of Type;
      type.name = type_name;
      type.package = type_package;
      type.default_value = type_default_value;
      type.resolve( s_dt:s_dt );
      create object instance builtin of BuiltInType;
      relate builtin to type across R407;
      builtin.primitive = type_primitive;
      builtin.unique = type_unique;
      builtin.inst = type_inst;
      builtin.instset = type_instset;
    end if;

  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("26bcd5a8-82fd-48ba-8dfc-40a65ebfd881",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	"00000000-0000-0000-0000-000000000000",
	'transformClass',
	'',
	'o_obj = param.o_obj;
containing_comp_def = param.containing_comp_def;
path = param.path;
select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];

// get exclude mark
select one pe related by o_obj->PE_PE[R8001];
select any class_exclude_mark from instances of Mark where ( selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
                                                            selected.feature_name == "Exclude" );
if ( empty class_exclude_mark )
  // get mark for naming
  select any class_name_mark from instances of Mark where ( selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
                                                            selected.feature_name == "UseKeyLettersForName" );
  // create the object file
  create object instance file of File;
  if ( empty class_name_mark )
    file.name = ::camelCaseName( name:o_obj.Name, start_lower:false );
  else
    file.name = ::camelCaseName( name:o_obj.Key_Lett, start_lower:false );
  end if;
  file.path = path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the object
  create object instance obj of Class;
  relate obj to file across R401;
  obj.key_letters = o_obj.Key_Lett;
  obj.extends = "ModelInstance<" + obj.name + "," + containing_comp_def.name + ">";

  // add the class to the component
  relate obj to containing_comp_def across R408;

  // create the instance type
  create object instance type of Type;
  type.name = obj.name;
  type.package = obj.package;
  select any s_irdt related by o_obj->S_IRDT[R123] where ( not selected.isSet );
  select one s_dt related by s_irdt->S_DT[R17];
  if ( not_empty s_dt )
    type.resolve( s_dt:s_dt );
  else
    // TODO bad
  end if;
  type.default_value = obj.name + "Impl.EMPTY_" + T::u( s:T::underscore( s:obj.name ) );
  relate type to obj across R407;

  // relate to the OOA class
  relate obj to o_obj across R409;

  // transform the set object
  ::transformClassSet( obj:obj, ep_pkg:ep_pkg, path:path );

  // transform attributes
  select any o_attr related by o_obj->O_ATTR[R102];
  select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  while ( not_empty prev_attr )
    o_attr = prev_attr;
    select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  end while;
  index = 0;
  while ( not_empty o_attr )
    if ( "current_state" != o_attr.Name )
      ::transformAttribute( o_attr:o_attr, obj:obj, index:index );
    end if;
    select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
    index = index + 1;
  end while;

  // transform operations
  select many o_tfrs related by o_obj->O_TFR[R115];
  for each o_tfr in o_tfrs
    ::transformOperation( o_tfr:o_tfr, obj:obj );
  end for;

  // add to the containing component imports
  select one component_file related by containing_comp_def->File[R401];
  select one set_file related by obj->ClassSet[R406.''is type of single element in'']->File[R401];
  ::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );
  ::addFileToImports( file:component_file, file_to_import:set_file, type:ImportType::IMPL );
  ::addStringToImports( file: component_file, s: ::pathToPackage( path:set_file.path ) + ".impl." + set_file.name + "Impl", type:ImportType::IMPL );
  ::addStringToImports( file: component_file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );

  // create the import block
  ::addFileToImports( file:file, file_to_import:component_file, type:ImportType::BOTH );

  ::addFileToImports( file:file, file_to_import:file, type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.application.IRunContext", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.InstancePopulationException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.ModelInstance", type:ImportType::IMPL );

  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IModelInstance", type:ImportType::INT );
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("aa6be7c4-dd4e-4044-bbf1-81678db4c1f5",
	"5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("9e76c7fd-92f6-44e6-92b5-aa4874148abc",
	"5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"aa6be7c4-dd4e-4044-bbf1-81678db4c1f5",
	'');
INSERT INTO S_SPARM
	VALUES ("3e13db8d-1aaf-4219-9775-40e0e6e7760a",
	"5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9e76c7fd-92f6-44e6-92b5-aa4874148abc",
	'');
INSERT INTO PE_PE
	VALUES ("5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a14540ae-c3dd-4248-890f-99953be47efa",
	"00000000-0000-0000-0000-000000000000",
	'transformClassSet',
	'',
	'obj = param.obj;
ep_pkg = param.ep_pkg;

// create the object file
create object instance file of File;
file.name = obj.name + "Set";
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the class set object
create object instance objset of ClassSet;
relate objset to obj across R406;
relate objset to file across R401;
objset.extends = "InstanceSet<" + objset.name + "," + obj.name + ">";

// create the instance type
create object instance type of Type;
type.name = objset.name;
type.package = objset.package;
select any s_irdt related by obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( not_empty s_dt )
  type.resolve( s_dt:s_dt );
else
  // TODO bad
end if;
type.default_value = "new " + objset.name + "Impl().toImmutableSet()";
relate type to objset across R407;

// create the import block
select one objfile related by obj->File[R401];
::addFileToImports( file:file, file_to_import:file, type: ImportType::IMPL );
::addFileToImports( file:file, file_to_import:objfile, type: ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.cairn.classes.InstanceSet", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IInstanceSet", type:ImportType::INT );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("ceb8a015-73b2-4bc0-acbc-a5fa93f21e67",
	"a14540ae-c3dd-4248-890f-99953be47efa",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ac93823e-2644-440b-977c-1f4e8480ec59",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class>',
	'',
	'',
	'../architecture/class/class.xtuml');
INSERT INTO S_SPARM
	VALUES ("72a8d944-1499-487e-9f40-06dbfc501f96",
	"a14540ae-c3dd-4248-890f-99953be47efa",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"ceb8a015-73b2-4bc0-acbc-a5fa93f21e67",
	'');
INSERT INTO S_SPARM
	VALUES ("12fcf0c4-7b5e-4554-9447-3aee57ad6bd7",
	"a14540ae-c3dd-4248-890f-99953be47efa",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"72a8d944-1499-487e-9f40-06dbfc501f96",
	'');
INSERT INTO PE_PE
	VALUES ("a14540ae-c3dd-4248-890f-99953be47efa",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("19215085-ca84-43cb-bb81-6ffd50262136",
	"00000000-0000-0000-0000-000000000000",
	'transformAttribute',
	'',
	'o_attr = param.o_attr;
obj = param.obj;

// create the attribute
create object instance attr of Attribute;
select one rattr related by o_attr->O_RATTR[R106];
if ( not_empty rattr )
  attr.name = "ref_" + o_attr.Name;
else
  attr.name = "m_" + o_attr.Name;
end if;
attr.base_name = o_attr.Name;
attr.order = param.index;
relate attr to obj across R410;

// set the type
select one s_dt related by o_attr->S_DT[R114];
if ( "same_as<Base_Attribute>" == s_dt.Name )
  select one s_dt related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
end if;
if ( empty s_dt )
  // TODO bad
end if;
select many s_dims related by o_attr->S_DIM[R120];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to attr across R424;

// link OOA attribute
relate o_attr to attr across R414;

// create accessors
create object instance getter of AttributeAccessor;
getter.accessor_type = AttributeAccessor::GETTER;
relate getter to attr across R4510.''gets and sets'';
create object instance setter of AttributeAccessor;
setter.accessor_type = AttributeAccessor::SETTER;
relate setter to attr across R4510.''gets and sets'';

// transform derivation
select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
if ( not_empty o_dbattr )
  create object instance deriv of AttributeDerivation;
  relate deriv to getter across R441.''calculates value for'';
  // create invocable
  create object instance invocable of InvocableObject;
  invocable.name = attr.name;
  invocable.parent_name = attr.class_name;
  invocable.parent_package = attr.class_package;
  relate deriv to invocable across R427;
  invocable.oal = o_dbattr.Action_Semantics_internal;
  // link type
  relate type to invocable across R428;
  // relate the body
  select one act_act related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698];
  if ( not_empty act_act )
    relate act_act to invocable across R432.''actions transformed from'';
  end if;
end if;

// add import to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::BOTH );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );

// add imports to object set file
select one set_file related by obj->ClassSet[R406]->File[R401];
::addStringToImports( file:set_file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::BOTH );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("7b1297b8-b278-4ae8-a571-70b7bf262f38",
	"19215085-ca84-43cb-bb81-6ffd50262136",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("7a7146b3-82c0-458a-bf9d-b99938b7d7c7",
	"19215085-ca84-43cb-bb81-6ffd50262136",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"7b1297b8-b278-4ae8-a571-70b7bf262f38",
	'');
INSERT INTO S_SPARM
	VALUES ("f7a15049-5fc1-480a-984f-23bce39894eb",
	"19215085-ca84-43cb-bb81-6ffd50262136",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"7a7146b3-82c0-458a-bf9d-b99938b7d7c7",
	'');
INSERT INTO PE_PE
	VALUES ("19215085-ca84-43cb-bb81-6ffd50262136",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a566ca37-5a57-4f7f-9212-c9cf475d697d",
	"00000000-0000-0000-0000-000000000000",
	'transformInstanceReferenceTypes',
	'',
	'// make sure an instance reference type is created for every class
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  select one packageableElem related by o_obj->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];

  // Make sure the IRDTs don''t already exist before creating new ones.  Check
  // the single and set version and create whatever does not exist.
  select any existing_irdt related by o_obj->S_IRDT[R123] where selected.isSet == false;
  if (empty existing_irdt)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt of S_DT;
    relate pe to dt across R8001;
    create object instance irdt of S_IRDT;
    irdt.isSet = false;
    relate dt to irdt across R17;
    dt.Name = "inst_ref<" + o_obj.Name + ">" ;
    relate o_obj to irdt across R123;
  end if;

  select any existing_irdt_set related by o_obj->S_IRDT[R123] where selected.isSet == true;
  if (empty existing_irdt_set)
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt2 of S_DT;
    relate pe to dt2 across R8001;
    create object instance irsdt of S_IRDT;
    irsdt.isSet = true;
    relate irsdt to dt2 across R17;
    dt2.Name = "inst_ref_set<" + o_obj.Name + ">" ;
    relate o_obj to irsdt across R123;
  end if;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("a566ca37-5a57-4f7f-9212-c9cf475d697d",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("eb2d19db-99fd-443a-891e-1510a4224c8a",
	"00000000-0000-0000-0000-000000000000",
	'transformEnumeratedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = type.name + ".UNINITIALIZED_ENUM";
type.resolve( s_dt:s_dt );
create object instance edt of EnumeratedType;
relate type to edt across R407;
relate edt to file across R401;

// transform enumerators
select many enums related by s_dt->S_EDT[R17]->S_ENUM[R27];
value = 0;
for each enumer in enums
  create object instance e of Enumerator;
  e.name = T::u( s:enumer.Name );
  e.value = value;
  value = value + 1;
  relate e to edt across R415;
end for;

// add to imports
::addStringToImports( file:file, s:"io.ciera.summit.types.IXtumlType", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("39ff61e1-b925-497a-8d8a-1ea86381dec4",
	"eb2d19db-99fd-443a-891e-1510a4224c8a",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("eb2d19db-99fd-443a-891e-1510a4224c8a",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("056fd761-beb4-4eed-85d2-b466883d17cb",
	"00000000-0000-0000-0000-000000000000",
	'resolveTypeImports',
	'',
	'select many types from instances of Type;
for each type in types
  select many impl_files from instances of File where false;
  select many both_files from instances of File where false;

  // find files
  select many files related by type->TypeReference[R3800]->Attribute[R424]->Class[R410]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Attribute[R424]->Class[R410]->ClassSet[R406.''is type of single element in'']->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Function[R427]->ComponentDefinition[R405.''can execute synchronously within'']->File[R401];
  both_files = both_files | files;

  select many inst_ops related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Operation[R427] where ( not selected.is_class_based );
  select many files related by inst_ops->Class[R416]->File[R401];
  both_files = both_files | files;

  select many class_ops related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Operation[R427] where ( selected.is_class_based );
  select many files related by class_ops->Class[R416]->File[R401];
  impl_files = impl_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->PortMessage[R427]->Message[R420.''provides implementation for'']->Interface[R419]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->PortMessage[R427]->Port[R420]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429.''shapes data for'']->UtilityFunction[R427]->Utility[R4559.''provided by'']->File[R401];
  both_files = both_files | files;

  select many inst_ops related by type->TypeReference[R3800]->InvocableObject[R428]->Operation[R427] where ( not selected.is_class_based );
  select many files related by inst_ops->Class[R416]->File[R401];
  both_files = both_files | files;

  select many class_ops related by type->TypeReference[R3800]->InvocableObject[R428]->Operation[R427] where ( selected.is_class_based );
  select many files related by class_ops->Class[R416]->File[R401];
  impl_files = impl_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428]->PortMessage[R427]->Message[R420.''provides implementation for'']->Interface[R419]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428]->PortMessage[R427]->Port[R420]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428.''defines return type for'']->UtilityFunction[R427]->Utility[R4559.''provided by'']->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Selector[R446.''shapes return of'']->InstanceSelector[R445]->Class[R442.''navigates from'']->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Selector[R446.''shapes return of'']->SetSelector[R445]->ClassSet[R444.''navigates from'']->File[R401];
  both_files = both_files | files;

  // add to imports
  for each file in impl_files
    type.addToImports( file:file, type:ImportType::IMPL );
  end for;
  for each file in both_files
    type.addToImports( file:file, type:ImportType::BOTH );
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("056fd761-beb4-4eed-85d2-b466883d17cb",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("03e1ea6e-74af-412c-b034-76ab7511674f",
	"00000000-0000-0000-0000-000000000000",
	'transformOperation',
	'',
	'o_tfr = param.o_tfr;
obj = param.obj;

// create function object
create object instance op of Operation;
op.is_class_based = Scope::Class == o_tfr.Instance_Based;
relate op to obj across R416;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = o_tfr.Name;
invocable.parent_name = op.class_name;
invocable.parent_package = op.class_package;
relate op to invocable across R427;
invocable.oal = o_tfr.Action_Semantics_internal;

// link type
select one s_dt related by o_tfr->S_DT[R116];
select many s_dims related by o_tfr->S_DIM[R122];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any o_tparm related by o_tfr->O_TPARM[R117];
prev_o_tparm = o_tparm;
// select first parameter
while ( not_empty prev_o_tparm )
  o_tparm = prev_o_tparm;
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
end while;
while ( not_empty o_tparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + o_tparm.Name;
  parm.by_ref = ( 1 == o_tparm.By_Ref );
  select one parm_dt related by o_tparm->S_DT[R118];
  select many s_dims related by o_tparm->S_DIM[R121];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
end while;

// relate the body
select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432.''actions transformed from'';
end if;

// add import for class based operations
if ( op.is_class_based )
  select one class_file related by obj->File[R401];
  ::addStringToImports( file:class_file, s:"io.ciera.cairn.application.ActionHome", type:ImportType::IMPL );
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("30ba3ab6-6d9c-4d33-bd48-006d0df3ab1c",
	"03e1ea6e-74af-412c-b034-76ab7511674f",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("36319cba-4224-4f29-ab04-3a8b3ee913a7",
	"03e1ea6e-74af-412c-b034-76ab7511674f",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"30ba3ab6-6d9c-4d33-bd48-006d0df3ab1c",
	'');
INSERT INTO PE_PE
	VALUES ("03e1ea6e-74af-412c-b034-76ab7511674f",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cae43083-b72d-40f8-95cb-4b31855ce3ee",
	"00000000-0000-0000-0000-000000000000",
	'transformInterface',
	'',
	'c_i = param.c_i;
select one ep_pkg related by c_i->PE_PE[R8001]->EP_PKG[R8000];
select one iface related by c_i->Interface[R421.''is basis for''];
if ( empty iface )

  // create the file
  create object instance file of File;
  file.name = ::camelCaseName( name:c_i.Name, start_lower:false );
  file.path = param.path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the interface package object
  create object instance iface of Interface;
  relate iface to file across R401;

  // relate to the c_i
  relate iface to c_i across R421;

  // transform messages
  select many c_eps related by c_i->C_EP[R4003];
  for each c_ep in c_eps
    ::transformMessage( c_ep:c_ep, iface:iface );
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("c871a7f5-dd47-49c0-ad37-2478c2c84f13",
	"cae43083-b72d-40f8-95cb-4b31855ce3ee",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("80698720-cc57-44ba-8aa5-600c524db338",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("3cdf04f6-57a6-4a09-933a-9f2bcb94e1ee",
	"cae43083-b72d-40f8-95cb-4b31855ce3ee",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c871a7f5-dd47-49c0-ad37-2478c2c84f13",
	'');
INSERT INTO PE_PE
	VALUES ("cae43083-b72d-40f8-95cb-4b31855ce3ee",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e5071316-f813-44a9-b6f4-51f4e3089418",
	"00000000-0000-0000-0000-000000000000",
	'transformMessage',
	'',
	'c_ep = param.c_ep;
iface = param.iface;
select one c_as related by c_ep->C_AS[R4004];
select one c_io related by c_ep->C_IO[R4004];

if ( not_empty c_as )  // TODO currently only support signals

// create message object
create object instance msg of Message;
msg.name = c_ep.Name;
msg.to_provider = true;
if ( not_empty c_as )
  msg.to_provider = ( c_as.Direction == IFDirectionType::ClientServer );
elif ( not_empty c_io )
  msg.to_provider = ( c_io.Direction == IFDirectionType::ClientServer );
end if;
relate msg to iface across R419;

end if;

select one file related by iface->File[R401];
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("d7b9fb63-0ec0-4363-bf10-f8cee68b219b",
	"e5071316-f813-44a9-b6f4-51f4e3089418",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("773be1d9-8ccf-438c-a765-b071c635f13f",
	"e5071316-f813-44a9-b6f4-51f4e3089418",
	'iface',
	"fb653c16-f8e6-4951-9132-f0d7d0319578",
	0,
	'',
	"d7b9fb63-0ec0-4363-bf10-f8cee68b219b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fb653c16-f8e6-4951-9132-f0d7d0319578",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../architecture/interface/interface.xtuml');
INSERT INTO PE_PE
	VALUES ("e5071316-f813-44a9-b6f4-51f4e3089418",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("48a30c71-bd16-4087-a818-1c1479c64a33",
	"00000000-0000-0000-0000-000000000000",
	'transformPort',
	'',
	'c_po = param.c_po;
comp_def = param.comp_def;
select one c_c related by c_po->C_C[R4010];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:c_po.Name, start_lower:false );
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the interface package object
create object instance port of Port;
relate port to file across R401;
relate port to c_po across R422;

// set port as provider or requirer
select any c_p related by c_po->C_IR[R4016]->C_P[R4009];
port.provider = not_empty c_p;

// relate to other component
relate port to comp_def across R417;

// relate to iface if the iface is there
select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
select one iface related by c_i->Interface[R421];
if ( empty iface and not_empty c_i )
  select one ep_pkg related by c_i->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    ::transformInterface( c_i:c_i, path: ::ep_pkgToPath( ep_pkg:ep_pkg ) );
  end if;
  select one iface related by c_i->Interface[R421];
end if;
if ( not_empty iface )
  relate port to iface across R418;
  select many msgs related by iface->Message[R419];
  for each msg in msgs
    ::transformPortMessage( port:port, msg:msg );
  end for;
  select one iface_file related by iface->File[R401];
  ::addFileToImports( file:file, file_to_import:iface_file, type:ImportType::IMPL );
else
  // TODO bad
end if;

// add to component file
select one component_file related by comp_def->File[R401];
::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );

// add imports
::addStringToImports( file:file, s:"io.ciera.cairn.interfaces.Port", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.BadArgumentException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.interfaces.IMessage", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.interfaces.IPort", type:ImportType::IMPL );
::addFileToImports( file:file, file_to_import:component_file, type:ImportType::IMPL );
select one iface_file related by iface->File[R401];
::addFileToImports( file:file, file_to_import:iface_file, type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4e27e7e4-b388-4b0c-93bb-d8ccf14f4478",
	"48a30c71-bd16-4087-a818-1c1479c64a33",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("751cc73a-dc3b-419c-b6dd-daba79556a01",
	"48a30c71-bd16-4087-a818-1c1479c64a33",
	'comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"4e27e7e4-b388-4b0c-93bb-d8ccf14f4478",
	'');
INSERT INTO S_SPARM
	VALUES ("756e5a83-04eb-4baa-801c-b40bddd118e4",
	"48a30c71-bd16-4087-a818-1c1479c64a33",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"751cc73a-dc3b-419c-b6dd-daba79556a01",
	'');
INSERT INTO PE_PE
	VALUES ("48a30c71-bd16-4087-a818-1c1479c64a33",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("65d02f39-685e-434b-971f-e57fb66067f8",
	"00000000-0000-0000-0000-000000000000",
	'transformAssociation',
	'',
	'r_rel = param.r_rel;
containing_comp_def = param.containing_comp_def;
select one file related by containing_comp_def->File[R401];
select one ep_pkg related by r_rel->PE_PE[R8001]->EP_PKG[R8000];

// get exclude mark
select one pe related by r_rel->PE_PE[R8001];
select any assoc_exclude_mark from instances of Mark where ( selected.markable_name == "Association" and
                                                             selected.path == ::containerMarkingPath( pe:pe ) + "::R" + STR::itoa( i:r_rel.Numb ) and
                                                             selected.feature_name == "Exclude" );
if ( empty assoc_exclude_mark )
  form_phrase = "";
  select any form_class from instances of Class where false;
  form_mult = Mult::ONE;
  part_mult = Mult::ONE;
  form_cond = Cond::UNCONDITIONAL;
  part_phrase = "";
  select any part_class from instances of Class where false;
  part_cond = Cond::UNCONDITIONAL;

  // create the relationsip subtype
  select one r_simp related by r_rel->R_SIMP[R206];
  if ( not_empty r_simp )

    // If there is no R_FORM and the multiplicity of both is ONE, one is chosen arbitrarily to be the formalizer
    select one r_form related by r_simp->R_FORM[R208];
    select one form_class related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty form_class )
      select any r_part related by r_simp->R_PART[R207];
      select one part_class related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
      if ( not_empty part_class )
        form_phrase = r_form.Txt_Phrs;
        part_phrase = r_part.Txt_Phrs;
        if ( 0 != r_form.Mult )
          form_mult = Mult::MANY;
        end if;
        if ( 0 != r_part.Mult )
          part_mult = Mult::MANY;
        end if;
        if ( 0 != r_form.Cond )
          form_cond = Cond::CONDITIONAL;
        end if;
        if ( 0 != r_part.Cond )
          part_cond = Cond::CONDITIONAL;
        end if;
      else
        // TODO bad
      end if;
    else
      select any r_part1 related by r_simp->R_PART[R207] where ( selected.Mult == 0 );
      if ( empty r_part1 )
        select any r_part1 related by r_simp->R_PART[R207]; // for many to many unformalized, select one randomly
      end if;
      if ( not_empty r_part1 )
        select one part_class related by r_part1->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
        select any r_part2 related by r_simp->R_PART[R207] where ( selected.OIR_ID != r_part1.OIR_ID );
        select one form_class related by r_part2->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
        if ( not_empty form_class and not_empty part_class )
          form_phrase = r_part2.Txt_Phrs;
          part_phrase = r_part1.Txt_Phrs;
          if ( 0 != r_part2.Mult )
            form_mult = Mult::MANY;
          end if;
          if ( 0 != r_part1.Mult )
            part_mult = Mult::MANY;
          end if;
          if ( 0 != r_part2.Cond )
            form_cond = Cond::CONDITIONAL;
          end if;
          if ( 0 != r_part1.Cond )
            part_cond = Cond::CONDITIONAL;
          end if;
        else
          // TODO bad
        end if;
      else
        // TODO bad unformalized many to many binary associations not supported
      end if;
    end if;

    // create the relationship
    create object instance rel of Relationship;
    name = "R" + STR::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name = name + T::underscore( s:part_phrase ) + "_";
    end if;
    name = name + part_class.name;
    rel.name = name;
    rel.num = r_rel.Numb;
    rel.form_phrase = form_phrase;
    rel.part_phrase = part_phrase;
    rel.form_mult = form_mult;
    rel.part_mult = part_mult;
    rel.form_cond = form_cond;
    rel.part_cond = part_cond;
    relate rel to containing_comp_def across R448.''forms relationship population of'';
    relate rel to form_class across R435.''has formalizing'';
    relate rel to part_class across R434.''has participating'';

  else
  select one r_subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty r_subsup )

    select one part_class related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    select many sub_classes related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty part_class and not_empty sub_classes )
      part_phrase = "is_a";
      for each form_class in sub_classes

        form_phrase = "is_a";
        form_cond = Cond::CONDITIONAL;

        // create the relationship
        create object instance rel of Relationship;
        name = "R" + STR::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
        if ( "" != part_phrase )
          name = name + part_phrase + "_";
        end if;
        name = name + part_class.name;
        rel.name = name;
        rel.num = r_rel.Numb;
        rel.form_phrase = form_phrase;
        rel.part_phrase = part_phrase;
        rel.form_mult = form_mult;
        rel.part_mult = part_mult;
        rel.form_cond = form_cond;
        rel.part_cond = part_cond;
        relate rel to containing_comp_def across R448.''forms relationship population of'';
        relate rel to form_class across R435.''has formalizing'';
        relate rel to part_class across R434.''has participating'';

      end for;
    else
      // TODO bad
    end if;

  else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )


    select one r_assr related by r_assoc->R_ASSR[R211];
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];

    select one form_class related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    select one part_class related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty form_class and not_empty part_class and not_empty r_aoth )
      form_phrase = r_aoth.Txt_Phrs;
      part_phrase = r_aone.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aoth.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aoth.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the first relationship
    create object instance rel1 of Relationship;
    name1 = "R" + STR::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name1 = name1 + T::underscore( s:part_phrase ) + "_";
    end if;
    name1 = name1 + part_class.name;
    rel1.name = name1;
    rel1.num = r_rel.Numb;
    rel1.form_phrase = form_phrase;
    rel1.part_phrase = part_phrase;
    rel1.form_mult = form_mult;
    rel1.part_mult = part_mult;
    rel1.form_cond = form_cond;
    rel1.part_cond = part_cond;
    relate rel1 to containing_comp_def across R448.''forms relationship population of'';
    relate rel1 to form_class across R435.''has formalizing'';
    relate rel1 to part_class across R434.''has participating'';

    form_phrase = "";
    form_mult = Mult::ONE;
    form_cond = Cond::UNCONDITIONAL;
    part_phrase = "";
    part_cond = Cond::UNCONDITIONAL;

    select one part_class related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty form_class and not_empty part_class and not_empty r_aone )
      form_phrase = r_aone.Txt_Phrs;
      part_phrase = r_aoth.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aone.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aone.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the second relationship
    create object instance rel2 of Relationship;
    name2 = "R" + STR::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name2 = name2 + T::underscore( s:part_phrase ) + "_";
    end if;
    name2 = name2 + part_class.name;
    rel2.name = name2;
    rel2.num = r_rel.Numb;
    rel2.form_phrase = form_phrase;
    rel2.part_phrase = part_phrase;
    rel2.form_mult = form_mult;
    rel2.part_mult = part_mult;
    rel2.form_cond = form_cond;
    rel2.part_cond = part_cond;
    relate rel2 to containing_comp_def across R448.''forms relationship population of'';
    relate rel2 to form_class across R435.''has formalizing'';
    relate rel2 to part_class across R434.''has participating'';

  else
    // TODO bad
  end if; end if; end if;

  // add necessary imports
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.RelationshipSet", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.Relationship", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationshipSet", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.BadArgumentException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.ModelIntegrityException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::IMPL );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("b3c53e3f-1986-4e3c-8047-04a969a3dd54",
	"65d02f39-685e-434b-971f-e57fb66067f8",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("c4877261-9b00-4291-af18-5490a8b591b9",
	"65d02f39-685e-434b-971f-e57fb66067f8",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"b3c53e3f-1986-4e3c-8047-04a969a3dd54",
	'');
INSERT INTO PE_PE
	VALUES ("65d02f39-685e-434b-971f-e57fb66067f8",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("805f004a-96b0-4655-b033-f9311da42460",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectors',
	'',
	'obj = param.obj;

// transform selectors for associations
// form to part
select many form_to_part_rels related by obj->Relationship[R435.''formalizes''];
for each rel in form_to_part_rels
  select one part_obj related by rel->Class[R434.''has participating''];
  ::transformSelector( obj:obj, rel:rel, phrase:rel.part_phrase, cond:rel.part_cond,
                       mult:rel.part_mult, formalizer:true, other_obj:part_obj );
end for;
// part to form
select many part_to_form_rels related by obj->Relationship[R434.''participates in''];
for each rel in part_to_form_rels
  select one form_obj related by rel->Class[R435.''has formalizing''];
  ::transformSelector( obj:obj, rel:rel, phrase:rel.form_phrase, cond:rel.form_cond,
                       mult:rel.form_mult, formalizer:false, other_obj:form_obj );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("20d5b38b-69c9-4fdd-a4d2-5fddb7bcf9bd",
	"805f004a-96b0-4655-b033-f9311da42460",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("805f004a-96b0-4655-b033-f9311da42460",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("47432932-84af-42f4-8df8-1fefb66ca9b3",
	"00000000-0000-0000-0000-000000000000",
	'transformSelector',
	'',
	'obj = param.obj;
rel = param.rel;
other_obj = param.other_obj;

// This function creates selectors for the class and set for a single path
// through a relationship. For single instances, a selectOne or selectMany
// are created based on multiplicity. For sets, a selectMany and is always
// created.

name = "R" + STR::itoa( i:rel.num ) + "_";
if ( "" != param.phrase )
  name = name + T::underscore( s:param.phrase ) + "_";
end if;
name = name + other_obj.name;

// create set selectors
select one obj_set related by obj->ClassSet[R406.''is type of single element in''];

// create ''many'' selector
create object instance sel of Selector;
sel.parent_name = obj_set.name;
sel.parent_package = obj_set.package;
sel.name = name;
sel.multiplicity = param.mult;
relate rel to sel across R4512.''traversed by'';
create object instance set_sel of SetSelector;
relate set_sel to sel across R445;
relate set_sel to obj_set across R444.''navigates from'';

// link up type
select any set_irdt related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
select one set_dt related by set_irdt->S_DT[R17];
if ( empty set_dt )
  // TODO bad
end if;
select many s_dims from instances of S_DIM where false;
set_type = TypeReference::getInstance( s_dt:set_dt, s_dims:s_dims );
relate set_type to sel across R446.''shapes return of'';

select any s_irdt related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( empty s_dt )
  // TODO bad
end if;
class_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );

// create the instance selectors
if ( Mult::ONE == param.mult )

  // create ''one'' selector
  create object instance sel of Selector;
  sel.parent_name = obj.name;
  sel.parent_package = obj.package;
  sel.name = name;
  sel.multiplicity = param.mult;
  relate rel to sel across R4512.''traversed by'';
  create object instance inst_sel of InstanceSelector;
  inst_sel.rel_num = rel.num;
  inst_sel.conditionality = param.cond;
  inst_sel.formalizer = param.formalizer;
  relate inst_sel to sel across R445;
  relate inst_sel to obj across R442.''navigates from'';
  relate inst_sel to set_sel across R4505.''invoked by'';

  // link up type
  relate class_type to sel across R446.''shapes return of'';

else

  // create ''many'' selector
  create object instance sel of Selector;
  sel.parent_name = obj.name;
  sel.parent_package = obj.package;
  sel.name = name;
  sel.multiplicity = param.mult;
  relate rel to sel across R4512.''traversed by'';
  create object instance inst_sel of InstanceSelector;
  inst_sel.rel_num = rel.num;
  inst_sel.conditionality = param.cond;
  inst_sel.formalizer = param.formalizer;
  relate inst_sel to sel across R445;
  relate inst_sel to obj across R442.''navigates from'';
  relate inst_sel to set_sel across R4505.''invoked by'';

  // link up type
  relate set_type to sel across R446.''shapes return of'';

end if;

// add imports to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::BOTH );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationshipSet", type:ImportType::IMPL );
if ( Cond::UNCONDITIONAL == param.cond or Mult::ONE == param.mult )
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.ModelIntegrityException", type:ImportType::IMPL );
end if;
if ( Mult::MANY == param.mult )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationship", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:set_type.type_package + ".impl." + set_type.type_name + "Impl", type:ImportType::IMPL );
else
  ::addStringToImports( file:file, s:class_type.type_package + ".impl." + class_type.type_name + "Impl", type:ImportType::IMPL );
end if;

// add imports to object set file
select one set_file related by obj_set->File[R401];
::addStringToImports( file:set_file, s:"io.ciera.summit.exceptions.XtumlException", type:ImportType::BOTH );
::addStringToImports( file:set_file, s:set_type.type_package + ".impl." + set_type.type_name + "Impl", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("b81cbde9-cf73-4bf5-b4f8-3eb2e2cc1593",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f708f32f-8d0f-40ec-9cc7-0fd1733c8f48",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'rel',
	"acea8715-3cc0-489c-a9e9-9521870ce9ab",
	0,
	'',
	"b81cbde9-cf73-4bf5-b4f8-3eb2e2cc1593",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("acea8715-3cc0-489c-a9e9-9521870ce9ab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relationship>',
	'',
	'',
	'../architecture/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("e4b07e41-5de1-453c-b389-7cab38261f79",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'cond',
	"a2a4c58a-abbb-4d3a-afee-8f80d4ab0cd4",
	0,
	'',
	"f708f32f-8d0f-40ec-9cc7-0fd1733c8f48",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a2a4c58a-abbb-4d3a-afee-8f80d4ab0cd4",
	"00000000-0000-0000-0000-000000000000",
	'Cond',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("1ac9195e-0a27-4cad-81de-677a96ff5688",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'mult',
	"8774ba5f-d952-424f-a26a-4815240d9ec8",
	0,
	'',
	"e4b07e41-5de1-453c-b389-7cab38261f79",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8774ba5f-d952-424f-a26a-4815240d9ec8",
	"00000000-0000-0000-0000-000000000000",
	'Mult',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("85857ae0-d439-4e33-b983-8e7ea2fa5d48",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'other_obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"978b3686-0ba2-478e-bd72-796331a47665",
	'');
INSERT INTO S_SPARM
	VALUES ("3e3e8b80-f33b-4e1a-955c-d4c477f6f8c0",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'formalizer',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"1ac9195e-0a27-4cad-81de-677a96ff5688",
	'');
INSERT INTO S_SPARM
	VALUES ("978b3686-0ba2-478e-bd72-796331a47665",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'phrase',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3e3e8b80-f33b-4e1a-955c-d4c477f6f8c0",
	'');
INSERT INTO PE_PE
	VALUES ("47432932-84af-42f4-8df8-1fefb66ca9b3",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	"00000000-0000-0000-0000-000000000000",
	'transformUtility',
	'',
	's_ee = param.s_ee;
ep_pkg = param.ep_pkg;
containing_comp_def = param.containing_comp_def;

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_ee.Key_Lett, start_lower:false );
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = param.exclude;

// create the utility object
create object instance utility of Utility;
relate utility to file across R401;

// relate the containing component
if ( not_empty containing_comp_def )
  create object instance util_ref of UtilityReference;
  relate utility to containing_comp_def across R4558 using util_ref;
  select one component_file related by containing_comp_def->File[R401];
  ::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );
  ::addStringToImports( file:component_file, s: ::pathToPackage( path:file.path ) + ".impl." + file.name + "Impl", type:ImportType::IMPL );
end if;

// transform each utility function
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  ::transformUtilityFunction( s_brg:s_brg, utility:utility );
end for;

// create import block
::addFileToImports( file:file, file_to_import:file, type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.cairn.util.Utility", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.summit.components.IComponent", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("3e2fdcea-3b0f-4b1e-9bc8-f44f1c434121",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	's_ee',
	"fc04695e-75c8-413e-a409-6dbc6465e011",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc04695e-75c8-413e-a409-6dbc6465e011",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<External Entity>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("2b01a5a1-1096-4eba-abb6-9c8d15e4bb40",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"17f7d23f-e0a1-41a5-9816-8fe56e4f9d41",
	'');
INSERT INTO S_SPARM
	VALUES ("42579ca2-d6b4-465a-8be0-bdfe32b0f0bc",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"2b01a5a1-1096-4eba-abb6-9c8d15e4bb40",
	'');
INSERT INTO S_SPARM
	VALUES ("17f7d23f-e0a1-41a5-9816-8fe56e4f9d41",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"3e2fdcea-3b0f-4b1e-9bc8-f44f1c434121",
	'');
INSERT INTO S_SPARM
	VALUES ("0fc5fb18-6d8e-4224-97dd-38e638cc1e44",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"42579ca2-d6b4-465a-8be0-bdfe32b0f0bc",
	'');
INSERT INTO PE_PE
	VALUES ("0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9280b1e4-c562-48f3-8530-1ad3cee50c62",
	"00000000-0000-0000-0000-000000000000",
	'transformUtilityFunction',
	'',
	's_brg = param.s_brg;
utility = param.utility;

// create utility function object
create object instance util_func of UtilityFunction;
relate util_func to utility across R4559.''provided by'';

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_brg.Name;
invocable.parent_name = utility.name;
invocable.parent_package = utility.package;
relate util_func to invocable across R427;
invocable.oal = s_brg.Action_Semantics_internal;

// link type
select one s_dt related by s_brg->S_DT[R20];
select many s_dims related by s_brg->S_DIM[R50];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any s_bparm related by s_brg->S_BPARM[R21];
prev_s_bparm = s_bparm;
// select first parameter
while ( not_empty prev_s_bparm )
  s_bparm = prev_s_bparm;
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
end while;
while ( not_empty s_bparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_bparm.Name;
  parm.by_ref = ( 1 == s_bparm.By_Ref );
  select one parm_dt related by s_bparm->S_DT[R22];
  select many s_dims related by s_bparm->S_DIM[R49];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
end while;

// relate bridge
relate s_brg to util_func across R4570.''is basis for'';',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("7a55a482-325f-4c69-8b40-f5000de09729",
	"9280b1e4-c562-48f3-8530-1ad3cee50c62",
	'utility',
	"93db392d-1bd7-4276-baa0-47f361e867b5",
	0,
	'',
	"ea9b2942-b98d-4911-9a84-fb52e87ac401",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("93db392d-1bd7-4276-baa0-47f361e867b5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Utility>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO S_SPARM
	VALUES ("ea9b2942-b98d-4911-9a84-fb52e87ac401",
	"9280b1e4-c562-48f3-8530-1ad3cee50c62",
	's_brg',
	"ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("9280b1e4-c562-48f3-8530-1ad3cee50c62",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b36bee85-a614-4d69-9feb-cda336242c18",
	"00000000-0000-0000-0000-000000000000",
	'transformAttributeReferences',
	'',
	'obj = param.obj;
select many attrs related by obj->Attribute[R410.''data abstracted by''];
for each attr in attrs
  select many o_refs related by attr->O_ATTR[R414.''is transformed from'']->O_RATTR[R106]->O_REF[R108];
  for each o_ref in o_refs
    select one r_rel related by o_ref->O_RTIDA[R111]->R_RTO[R110]->R_OIR[R203]->R_REL[R201];
    select one referred_to_attr related by o_ref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105]->Attribute[R414.''is basis for''];
    select one referred_to_obj related by referred_to_attr->Class[R410.''abstracts data for''];
    referred_to_phrase = ::oirGetPhrase( r_oir_id:o_ref.ROIR_ID );
    phrase = ::oirGetPhrase( r_oir_id:o_ref.OIR_ID );
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == obj.name and
                                                                   selected.part_name == referred_to_obj.name and
                                                                   ( selected.form_phrase == phrase or selected.part_phrase == referred_to_phrase ) );

    // create attribute reference
    create object instance attr_ref of AttributeReference;
    relate attr to referred_to_attr across R4506.''has value provided by'' using attr_ref;
    relate relationship to attr_ref across R4511.''provides link for'';
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("305d84cf-5ace-4032-bde8-9f647e76e318",
	"b36bee85-a614-4d69-9feb-cda336242c18",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b36bee85-a614-4d69-9feb-cda336242c18",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4c082589-b030-438b-be8e-93dad37a6df3",
	"00000000-0000-0000-0000-000000000000",
	'transformBody',
	'',
	'invocable = param.invocable;
select one act_act related by invocable->ACT_ACT[R432.''transforms actions from''];
if ( not_empty act_act and not_empty invocable )

  select any upper_block from instances of CodeBlock where false;
  select one act_blk related by act_act->ACT_BLK[R666];
  ::transformBlock( invocable:invocable, upper_block:upper_block, act_blk:act_blk, block_number:"1" );

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("c5bdf924-36f6-42d6-b2c5-e3690fe23749",
	"4c082589-b030-438b-be8e-93dad37a6df3",
	'invocable',
	"30c7a5ba-c6d9-44fd-8e61-f22cde8fdc41",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("30c7a5ba-c6d9-44fd-8e61-f22cde8fdc41",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocable Object>',
	'',
	'',
	'../architecture/invocable/invocable.xtuml');
INSERT INTO PE_PE
	VALUES ("4c082589-b030-438b-be8e-93dad37a6df3",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("32c6aeb5-838d-4564-a401-ffc6720e4e0c",
	"00000000-0000-0000-0000-000000000000",
	'transformStatement',
	'',
	'act_smt = param.act_smt;
block = param.block;
prev_smt = param.prev_smt;
if ( not_empty act_smt and not_empty block )

  // create a statement
  create object instance smt of Statement;
  relate smt to block across R450.''is contained by'';
  if ( not_empty prev_smt )
    smt.statement_number = STR::itoa( i:STR::atoi( s:prev_smt.statement_number ) + 1 );
    relate smt to prev_smt across R477.''executes after'';
  else
    smt.statement_number = "1";
  end if;
  select one body related by block->InvocableObject[R4000.''is invoked in''];
  smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

  select one act_brg related by act_smt->ACT_BRG[R603];
  if ( not_empty act_brg )
    select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570.''is basis for''];
    if ( empty util_func )
      select one s_ee related by act_brg->S_BRG[R674]->S_EE[R19];
      select one s_ee_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
      select any empty_comp_def from instances of ComponentDefinition where false;
      ::transformUtility( s_ee:s_ee, ep_pkg:s_ee_pkg, containing_comp_def:empty_comp_def, exclude:true, path: ::ep_pkgToPath( ep_pkg:s_ee_pkg ) );
      select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570.''is basis for''];
    end if;
    select one invocable related by util_func->InvocableObject[R427];
    select one utility related by util_func->Utility[R4559.''provided by''];
    select one utility_file related by utility->File[R401];
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    select one containing_comp_file related by containing_comp_def->File[R401];
    ::addFileToImports( file:containing_comp_file, file_to_import:utility_file, type:ImportType::IMPL );
    ::addStringToImports( file:containing_comp_file, s: ::pathToPackage( path:utility_file.path ) + ".impl." + utility_file.name + "Impl", type:ImportType::IMPL );
    if ( not_empty containing_comp_def )
      select any util_ref related by utility->UtilityReference[R4558] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
      if ( empty util_ref )
        create object instance util_ref of UtilityReference;
        relate utility to containing_comp_def across R4558.''used within context of'' using util_ref;
      end if;
    end if;
    if ( not_empty invocable )
      // create expression as statement
      create object instance eas of ExpressionAsStatement;
      relate eas to smt across R451;
      // create main expression
      create object instance expr of Expression;
      relate expr to smt across R775.''expressed within'';
      expr.expression_number = "1";
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr across R795;
      // create invocation
      create object instance invoc of Invocation;
      relate invoc to expr across R776;
      relate invoc to invocable across R792;
      // relate expression to expression as statement
      relate eas to expr across R476.''executes as statement'';
      // create named reference expression
      create object instance expr2 of Expression;
      relate expr2 to smt across R775.''expressed within'';
      expr2.expression_number = "1.1";
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr2 across R795;
      // create named reference
      create object instance named_ref of NamedReference;
      relate named_ref to expr2 across R776;
      relate expr2 to invoc across R798.''is used as basis for'';
      named_ref.name = "context()." + utility.name + "()";
      // transform actual parameters
      select many v_pars related by act_brg->V_PAR[R628];
      ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
    else
      // TODO bad
    end if;
    
  else
  select one act_fnc related by act_smt->ACT_FNC[R603];
  if ( not_empty act_fnc )
    select one s_sync related by act_fnc->S_SYNC[R675];
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    select any invocable related by containing_comp_def->Function[R405.''provides synchronous'']->InvocableObject[R427] where ( selected.name == s_sync.Name );
    if ( not_empty invocable )
      // create expression as statement
      create object instance eas of ExpressionAsStatement;
      relate eas to smt across R451;
      // create main expression
      create object instance expr of Expression;
      relate expr to smt across R775.''expressed within'';
      expr.expression_number = "1";
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr across R795;
      // create invocation
      create object instance invoc of Invocation;
      relate invoc to expr across R776;
      relate invoc to invocable across R792;
      // relate expression to expression as statement
      relate eas to expr across R476.''executes as statement'';
      // create named reference expression
      create object instance expr2 of Expression;
      relate expr2 to smt across R775.''expressed within'';
      expr2.expression_number = "1.1";
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr2 across R795;
      // create named reference
      create object instance named_ref of NamedReference;
      relate named_ref to expr2 across R776;
      relate expr2 to invoc across R798.''is used as basis for'';
      named_ref.name = "context()";
      // transform actual parameters
      select many v_pars related by act_fnc->V_PAR[R669];
      ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
    else
      // TODO bad
    end if;

  else
  select one act_tfm related by act_smt->ACT_TFM[R603];
  if ( not_empty act_tfm )
    select one o_tfr related by act_tfm->O_TFR[R673];
    select any invocable related by o_tfr->O_OBJ[R115]->Class[R409]->Operation[R416.''provides'']->InvocableObject[R427] where ( selected.name == o_tfr.Name );
    if ( not_empty invocable )
      // create expression as statement
      create object instance eas of ExpressionAsStatement;
      relate eas to smt across R451;
      // create main expression
      create object instance expr of Expression;
      relate expr to smt across R775.''expressed within'';
      expr.expression_number = "1";
      relate eas to expr across R476.''executes as statement'';
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr across R795;
      // create invocation
      create object instance invoc of Invocation;
      relate invoc to expr across R776;
      relate invoc to invocable across R792;
      // relate expression to expression as statement
      select one op_v_var related by act_tfm->V_VAR[R667];
      if ( empty op_v_var ) // class based operation
        // create named reference expression
        create object instance expr2 of Expression;
        relate expr2 to smt across R775.''expressed within'';
        expr2.expression_number = "1.1";
        relate expr2 to invoc across R798.''is used as basis for'';
        void_type = TypeReference::getBuiltinTypeReference( name:"void" );
        relate void_type to expr2 across R795;
        // create named reference
        create object instance named_ref of NamedReference;
        relate named_ref to expr2 across R776;
        select one target_class related by invocable->Operation[R427]->Class[R416.''provided by''];
        named_ref.name = "new " + target_class.name + "Impl.CLASS(context())";
        select one class_file related by target_class->File[R401];
        ::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
      else // instance based operation
        // create variable reference expression
        create object instance expr2 of Expression;
        relate expr2 to smt across R775.''expressed within'';
        expr2.expression_number = "1.1";
        relate expr2 to invoc across R798.''is used as basis for'';
        select one op_s_dt related by op_v_var->S_DT[R848];
        select one op_obj related by o_tfr->O_OBJ[R115];
        op_s_dt = ::getInstRefTypeForClass( s_dt:op_s_dt, o_obj:op_obj );
        select many s_dims related by op_v_var->S_DIM[R849];
        op_type = TypeReference::getInstance( s_dt:op_s_dt, s_dims:s_dims );
        relate op_type to expr2 across R795.''defines type of'';
        select any op_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == op_v_var.Name );
        if ( not_empty op_var ) // cannot declare two variables of the same name in the same scope
          create object instance var_ref of VariableReference;
          relate op_var to var_ref across R782.''referenced through'';
          relate var_ref to expr2 across R776;
          select one type related by expr2->TypeReference[R795]->Type[R3800];
          ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
        elif ( "self" == op_v_var.Name )
          // create named reference
          create object instance self_ref of NamedReference;
          relate self_ref to expr2 across R776;
          self_ref.name = "this";
        else
          // TODO bad
        end if;
      end if;
      // transform actual parameters
      select many v_pars related by act_tfm->V_PAR[R627];
      ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
    else
      // TODO bad
    end if;

  else
  select one act_sgn related by act_smt->ACT_SGN[R603];
  if ( not_empty act_sgn )
    select one spr_rs related by act_sgn->SPR_RS[R660];
    select one spr_ps related by act_sgn->SPR_PS[R663];
    select one c_ep related by spr_rs->SPR_REP[R4502]->C_EP[R4500];
    if ( empty c_ep )
      select one c_ep related by spr_ps->SPR_PEP[R4503]->C_EP[R4501];
    end if;
    select one c_po related by spr_rs->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009]->C_PO[R4016];
    if ( empty c_po )
      select one c_po related by spr_ps->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009]->C_PO[R4016];
    end if;
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    select one target_port related by c_po->Port[R422.''is basis for''];
    select any invocable related by target_port->PortMessage[R420]->InvocableObject[R427] where ( selected.name == c_ep.Name );
    if ( not_empty invocable )
      // create expression as statement
      create object instance eas of ExpressionAsStatement;
      relate eas to smt across R451;
      // create main expression
      create object instance expr of Expression;
      relate expr to smt across R775.''expressed within'';
      expr.expression_number = "1";
      relate eas to expr across R476.''executes as statement'';
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr across R795;
      // create invocation
      create object instance invoc of Invocation;
      relate invoc to expr across R776;
      relate invoc to invocable across R792;
      // create named reference expression
      create object instance expr2 of Expression;
      relate expr2 to smt across R775.''expressed within'';
      expr2.expression_number = "1.1";
      relate expr2 to invoc across R798.''is used as basis for'';
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr2 across R795;
      // create named reference
      create object instance named_ref of NamedReference;
      relate named_ref to expr2 across R776;
      named_ref.name = "context()." + target_port.name + "()";
      select one port_file related by target_port->File[R401];
      ::addFileToImports( file: ::getFileForStatement( smt:smt ), file_to_import:port_file, type:ImportType::IMPL );
      // transform actual parameters
      select many v_pars related by act_sgn->V_PAR[R662];
      ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
    else
      // TODO bad
    end if;

  else
  select one act_if related by act_smt->ACT_IF[R603];
  if ( not_empty act_if )
    select any empty_invocable from instances of InvocableObject where false;
    // create if statement
    create object instance if_smt of IfSmt;
    relate if_smt to smt across R451;
    if_smt.is_else_if = false;
    // translate if expression
    select one if_val related by act_if->V_VAL[R625];
    ::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
    select any if_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1" );
    relate if_expr to if_smt across R471.''determines execution of blocks for'';
    // create then block
    then_block_number = ::getNextBlockNumber( upper_block:block );
    select one then_blk related by act_if->ACT_BLK[R607];
    ::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocable:empty_invocable );
    select any then_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == then_block_number );
    relate then_block to if_smt across R453.''controls then for'';
    // translate elifs
    select many act_els related by act_if->ACT_EL[R682];
    select many translated_act_els from instances of ACT_EL where false;
    remaining_act_els = act_els - translated_act_els;
    while ( not_empty remaining_act_els )
      // get the next elif
      select any act_el from instances of ACT_EL where false;
      for each remaining_act_el in remaining_act_els
        if ( empty act_el )
          act_el = remaining_act_el;
        else
          select one act_el_smt related by act_el->ACT_SMT[R603];
          select one remaining_act_el_smt related by remaining_act_el->ACT_SMT[R603];
          if ( remaining_act_el_smt.LineNumber < act_el_smt.LineNumber or
               remaining_act_el_smt.LineNumber == act_el_smt.LineNumber and remaining_act_el_smt.StartPosition == act_el_smt.StartPosition )
            act_el = remaining_act_el;
          end if;
        end if;
      end for;
      // create block for elif
      elif_block_number = ::getNextBlockNumber( upper_block:block );
      ::transformBlockForElif( upper_block:block, act_el:act_el, block_number:elif_block_number );
      select any else_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == elif_block_number );
      relate else_block to if_smt across R454.''controls else for'';
      // set the new current block and if statement
      block = else_block;
      select any if_smt related by if_smt->CodeBlock[R454.''has else'']->Statement[R450.''is scope for'']->IfSmt[R451];
      // mark the elif as translated
      translated_act_els = translated_act_els + act_el;
      remaining_act_els = act_els - translated_act_els;
    end while;
    // create else block
    else_block_number = ::getNextBlockNumber( upper_block:block );
    select one else_blk related by act_if->ACT_E[R683]->ACT_BLK[R606];
    if ( not_empty else_blk )
      ::transformBlock( upper_block:block, act_blk:else_blk, block_number:else_block_number, invocable:empty_invocable );
      select any else_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == else_block_number );
      relate else_block to if_smt across R454.''controls else for'';
    end if;

  else
  select one act_whl related by act_smt->ACT_WHL[R603];
  if ( not_empty act_whl )
    select any empty_invocable from instances of InvocableObject where false;
    // create while statement
    create object instance while_smt of WhileSmt;
    relate while_smt to smt across R451;
    // translate while expression
    select one while_val related by act_whl->V_VAL[R626];
    ::transformExpression( v_val:while_val, expr_number:"1", smt:smt );
    select any while_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1" );
    relate while_expr to while_smt across R472.''determines execution of block for'';
    // create control block
    control_block_number = ::getNextBlockNumber( upper_block:block );
    select one control_blk related by act_whl->ACT_BLK[R608];
    ::transformBlock( upper_block:block, act_blk:control_blk, block_number:control_block_number, invocable:empty_invocable );
    select any control_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == control_block_number );
    relate control_block to while_smt across R456.''controls'';

  else
  select one act_brk related by act_smt->ACT_BRK[R603];
  if ( not_empty act_brk )
    // create break statement
    create object instance break_smt of BreakSmt;
    relate break_smt to smt across R451;

  else
  select one act_con related by act_smt->ACT_CON[R603];
  if ( not_empty act_con )
    // create continue statement
    create object instance continue_smt of ContinueSmt;
    relate continue_smt to smt across R451;

  else
  select one act_ai related by act_smt->ACT_AI[R603];
  if ( not_empty act_ai )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    // create binary operation and assignment expression
    create object instance binop of BinaryOperation;
    relate binop to expr across R776;
    binop.operator = "=";
    binop.invocation = false;
    // relate expression to expression as statement
    relate eas to expr across R476.''executes as statement'';
    // create left operand
    select one l_val related by act_ai->V_VAL[R689];
    ::transformExpression( v_val:l_val, expr_number:"1.1", smt:smt );
    select any l_op related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.1" );
    relate l_op to binop across R779.''is left operand for'';
    // create right operand
    select one r_val related by act_ai->V_VAL[R609];
    ::transformExpression( v_val:r_val, expr_number:"1.2", smt:smt );
    select any r_op related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2" );
    relate r_op to binop across R778.''is right operand for'';
    // link r_op type to the main expression
    select one type related by r_op->TypeReference[R795];
    relate type to expr across R795.''defines type of'';

  else
  select one act_for related by act_smt->ACT_FOR[R603];
  if ( not_empty act_for )
    // create for statement
    create object instance for_smt of ForSmt;
    relate for_smt to smt across R451;
    // translate iterable expression
    select one iterable_v_var related by act_for->V_VAR[R652];
    select one iterable_o_obj related by iterable_v_var->V_INS[R814]->O_OBJ[R819];
    select any iterable_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == iterable_v_var.Name );
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    select one s_dt related by iterable_v_var->S_DT[R848];
    s_dt = ::getInstRefTypeForClass( s_dt:s_dt, o_obj:iterable_o_obj );
    select many s_dims related by iterable_v_var->S_DIM[R849];
    type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
    relate type to expr across R795.''defines type of'';
    create object instance var_ref of VariableReference;
    relate iterable_var to var_ref across R782.''referenced through'';
    relate var_ref to expr across R776;
    relate expr to for_smt across R478.''is iterated by'';
    select one expr_type related by expr->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
    // create iterator variable
    select one iter_v_var related by act_for->V_VAR[R614];
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == iter_v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:iter_v_var, smt:smt );
    end if;
    select any iter_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == iter_v_var.Name );
    relate iter_var to for_smt across R459.''is iterator for'';
    // link iterator variable type
    select one iter_type related by iter_var->TypeReference[R461]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:iter_type, type:ImportType::IMPL );
    // create control block
    control_block_number = ::getNextBlockNumber( upper_block:block );
    select one control_blk related by act_for->ACT_BLK[R605];
    ::transformBlockForFor( upper_block:block, act_blk:control_blk, block_number:control_block_number, iter_var:iter_var, for_smt:for_smt );
    select any control_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == control_block_number );
    relate control_block to for_smt across R455.''controls'';
    for_smt.initializeIterator();
    ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:"java.util.Iterator", type:ImportType::IMPL );

  else
  select one act_fio related by act_smt->ACT_FIO[R603];
  if ( not_empty act_fio )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    // create binary operation and assignment expression
    create object instance binop of BinaryOperation;
    relate binop to expr across R776;
    binop.operator = "=";
    binop.invocation = false;
    // relate expression to expression as statement
    relate eas to expr across R476.''executes as statement'';
    // create left operand
    select one select_v_var related by act_fio->V_VAR[R639];
    create object instance l_op of Expression;
    relate l_op to smt across R775.''expressed within'';
    l_op.expression_number = "1.1";
    select one select_s_dt related by select_v_var->S_DT[R848];
    select one select_obj related by act_fio->O_OBJ[R677];
    select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
    select many s_dims related by select_v_var->S_DIM[R849];
    select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims );
    relate select_type to l_op across R795.''defines type of'';
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:select_v_var, smt:smt );
    end if;
    select any select_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    create object instance var_ref of VariableReference;
    relate select_var to var_ref across R782.''referenced through'';
    relate var_ref to l_op across R776;
    relate l_op to binop across R779.''is left operand for'';
    select one expr_type related by l_op->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
    // create right operand
    select one selector related by select_obj->Class[R409.''is basis for'']->InstancePopulationSelector[R449.''extent accessed by''];
    create object instance r_op of Expression;
    relate r_op to smt across R775.''expressed within'';
    r_op.expression_number = "1.2";
    relate r_op to binop across R778.''is right operand for'';
    select any s_irdt related by act_fio->O_OBJ[R677]->S_IRDT[R123] where ( selected.isSet );
    select one s_dt related by s_irdt->S_DT[R17];
    select many s_dims from instances of S_DIM where false;
    fio_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
    relate fio_type to r_op across R795.''defines type of'';
    if ( "any" == act_fio.cardinality ) // create another expression for the ''any''. Note that this is a little tricky because the local var ''r_op'' is being reused
      create object instance any_expr of AnyExpr;
      relate any_expr to r_op across R776;
      create object instance r_op of Expression;
      relate r_op to smt across R775.''expressed within'';
      r_op.expression_number = "1.2.1";
      relate select_type to r_op across R795.''defines type of'';
      relate r_op to any_expr across R783.''is basis for'';
    end if;
    create object instance sel of SelectExpr;
    relate sel to r_op across R776;
    create object instance sel_fi of SelectFromInstances;
    relate sel_fi to sel across R789;
    relate selector to sel_fi across R799.''invoked by'';
    // link select type to the main expression
    relate select_type to expr across R795.''defines type of'';

  else
  select one act_fiw related by act_smt->ACT_FIW[R603];
  if ( not_empty act_fiw )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    // create binary operation and assignment expression
    create object instance binop of BinaryOperation;
    relate binop to expr across R776;
    binop.operator = "=";
    binop.invocation = false;
    // relate expression to expression as statement
    relate eas to expr across R476.''executes as statement'';
    // create left operand
    select one select_v_var related by act_fiw->V_VAR[R665];
    create object instance l_op of Expression;
    relate l_op to smt across R775.''expressed within'';
    l_op.expression_number = "1.1";
    select one select_s_dt related by select_v_var->S_DT[R848];
    select one select_obj related by act_fiw->O_OBJ[R676];
    select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
    select many s_dims related by select_v_var->S_DIM[R849];
    select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims );
    relate select_type to l_op across R795.''defines type of'';
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:select_v_var, smt:smt );
    end if;
    select any select_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    create object instance var_ref of VariableReference;
    relate select_var to var_ref across R782.''referenced through'';
    relate var_ref to l_op across R776;
    relate l_op to binop across R779.''is left operand for'';
    select one type related by l_op->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    // create right operand
    select one where_clause_val related by act_fiw->V_VAL[R610];
    select one where_clause_lbo related by where_clause_val->V_LBO[R801];
    if ( not_empty where_clause_lbo and ( "false" == T::l( s:where_clause_lbo.Value ) ) ) // special case where the where clause is ''false''
      create object instance r_op of Expression;
      relate r_op to smt across R775.''expressed within'';
      r_op.expression_number = "1.2";
      relate r_op to binop across R778.''is right operand for'';
      relate select_type to r_op across R795;
      create object instance named_expr of NamedReference;
      relate named_expr to r_op across R776;
      select one select_type_def related by select_type->Type[R3800];
      named_expr.name = select_type_def.default_value;
      ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:select_type_def.package + ".impl." + select_type_def.name + "Impl", type:ImportType::IMPL );
    else
      select one selector related by select_obj->Class[R409.''is basis for'']->InstancePopulationSelector[R449.''extent accessed by''];
      create object instance r_op of Expression;
      relate r_op to smt across R775.''expressed within'';
      r_op.expression_number = "1.2";
      relate select_type to r_op across R795.''defines type of'';
      relate r_op to binop across R778.''is right operand for'';
      create object instance where_expr of WhereExpr;
      relate where_expr to r_op across R776;
      where_expr.multiplicity = act_fiw.cardinality;
      // create selection expr
      create object instance sel_expr of Expression;
      relate sel_expr to smt across R775.''expressed within'';
      sel_expr.expression_number = "1.2.1";
      select any s_irdt related by act_fiw->O_OBJ[R676]->S_IRDT[R123] where ( selected.isSet );
      select one s_dt related by s_irdt->S_DT[R17];
      select many s_dims from instances of S_DIM where false;
      fiw_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
      relate fiw_type to sel_expr across R795.''defines type of'';
      relate sel_expr to where_expr across R790.''filtered by'';
      create object instance sel of SelectExpr;
      relate sel to sel_expr across R776;
      create object instance sel_fi of SelectFromInstances;
      relate sel_fi to sel across R789;
      relate selector to sel_fi across R799.''invoked by'';
      // transform the where clause condition
      ::transformExpression( v_val:where_clause_val, expr_number:"1.2.2", smt:smt );
      select any where_clause_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2.2" );
      relate where_clause_expr to where_expr across R796.''defines condtion for'';
    end if;
    // link select type to the main expression
    relate select_type to expr across R795.''defines type of'';

  else
  select one act_sel related by act_smt->ACT_SEL[R603];
  if ( not_empty act_sel )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    // create binary operation and assignment expression
    create object instance binop of BinaryOperation;
    relate binop to expr across R776;
    binop.operator = "=";
    binop.invocation = false;
    // relate expression to expression as statement
    relate eas to expr across R476.''executes as statement'';
    // create left operand
    select one select_v_var related by act_sel->V_VAR[R638];
    create object instance l_op of Expression;
    relate l_op to smt across R775.''expressed within'';
    l_op.expression_number = "1.1";
    select one select_s_dt related by select_v_var->S_DT[R848];
    select one last_lnk related by act_sel->ACT_LNK[R637];
    select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
    while ( not_empty next_lnk )
      last_lnk = next_lnk;
      select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
    end while;
    select one select_obj related by last_lnk->O_OBJ[R678];
    select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
    select many s_dims related by select_v_var->S_DIM[R849];
    select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims );
    relate select_type to l_op across R795.''defines type of'';
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:select_v_var, smt:smt );
    end if;
    select any select_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == select_v_var.Name );
    create object instance var_ref of VariableReference;
    relate select_var to var_ref across R782.''referenced through'';
    relate var_ref to l_op across R776;
    relate l_op to binop across R779.''is left operand for'';
    select one type related by l_op->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    // create right operand
    select one where_clause_val related by act_sel->ACT_SRW[R664]->V_VAL[R611];
    select one where_clause_lbo related by where_clause_val->V_LBO[R801];
    if ( not_empty where_clause_lbo and ( "false" == T::l( s:where_clause_lbo.Value ) ) ) // special case where the where clause is ''false''
      create object instance r_op of Expression;
      relate r_op to smt across R775.''expressed within'';
      r_op.expression_number = "1.2";
      relate r_op to binop across R778.''is right operand for'';
      relate select_type to r_op across R795;
      create object instance named_expr of NamedReference;
      relate named_expr to r_op across R776;
      select one select_type_def related by select_type->Type[R3800];
      named_expr.name = select_type_def.default_value;
      ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:select_type_def.package + ".impl." + select_type_def.name + "Impl", type:ImportType::IMPL );
    else
      // get the final selection chain link
      select one lnk related by act_sel->ACT_LNK[R637];
      select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
      while ( not_empty next_lnk )
        lnk = next_lnk;
        select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
      end while;
      if ( not_empty where_clause_val or "any" == act_sel.cardinality )
        create object instance r_op of Expression;
        relate r_op to smt across R775.''expressed within'';
        r_op.expression_number = "1.2";
        relate select_type to r_op across R795.''defines type of'';
        relate r_op to binop across R778.''is right operand for'';
        relate select_type to r_op across R795.''defines type of'';
        // create expression for last chain link
        ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2.1", smt:smt );
        if ( not_empty where_clause_val )
          create object instance where_expr of WhereExpr;
          relate where_expr to r_op across R776;
          where_expr.multiplicity = act_sel.cardinality;
          // select the transformed link, relate it to the where clause
          select any select_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2.1" );
          relate select_expr to where_expr across R790;
          // transform the where clause condition
          ::transformExpression( v_val:where_clause_val, expr_number:"1.2.2", smt:smt );
          select any where_clause_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2.2" );
          relate where_clause_expr to where_expr across R796.''defines condtion for'';
        else
          create object instance any_expr of AnyExpr;
          relate any_expr to r_op across R776;
          // select the transformed link, relate it to the any expression
          select any select_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2.1" );
          relate select_expr to any_expr across R783.''is basis for'';
        end if;
      else
        // create expression for last chain link
        ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2", smt:smt );
        // select the transformed link, relate it to the
        select any select_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1.2" );
        relate select_expr to binop across R778.''is right operand for'';
      end if;
    end if;
    // link select type to the main expression
    relate select_type to expr across R795.''defines type of'';
 
  else 
  select one act_cr related by act_smt->ACT_CR[R603];
  if ( not_empty act_cr )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    // create binary operation and assignment expression
    create object instance binop of BinaryOperation;
    relate binop to expr across R776;
    binop.operator = "=";
    binop.invocation = false;
    // relate expression to expression as statement
    relate eas to expr across R476.''executes as statement'';
    // create left operand
    select one cr_v_var related by act_cr->V_VAR[R633];
    create object instance l_op of Expression;
    relate l_op to smt across R775.''expressed within'';
    l_op.expression_number = "1.1";
    select one cr_s_dt related by cr_v_var->S_DT[R848];
    select one cr_obj related by act_cr->O_OBJ[R671];
    cr_s_dt = ::getInstRefTypeForClass( s_dt:cr_s_dt, o_obj:cr_obj );
    select many s_dims related by cr_v_var->S_DIM[R849];
    cr_type = TypeReference::getInstance( s_dt:cr_s_dt, s_dims:s_dims );
    relate cr_type to l_op across R795.''defines type of'';
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == cr_v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:cr_v_var, smt:smt );
    end if;
    select any cr_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == cr_v_var.Name );
    create object instance var_ref of VariableReference;
    relate cr_var to var_ref across R782.''referenced through'';
    relate var_ref to l_op across R776;
    relate l_op to binop across R779.''is left operand for'';
    select one type related by l_op->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    // create right operand
    create object instance r_op of Expression;
    relate r_op to smt across R775.''expressed within'';
    r_op.expression_number = "1.2";
    relate cr_type to r_op across R795.''defines type of'';
    create object instance cr of Creation;
    relate cr to r_op across R776;
    select one obj related by cr_obj->Class[R409.''is basis for''];
    relate cr to obj across R780.''creates'';
    relate r_op to binop across R778.''is right operand for'';
    select one class_file related by obj->File[R401];
    ::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
    // link create type to the main expression
    relate cr_type to expr across R795.''defines type of'';

  else
  select one act_cnv related by act_smt->ACT_CNV[R603];
  if ( not_empty act_cnv )
    // create expression as statement
    create object instance eas of ExpressionAsStatement;
    relate eas to smt across R451;
    // create main expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    relate eas to expr across R476.''executes as statement'';
    select any s_irdt related by act_cnv->O_OBJ[R672]->S_IRDT[R123] where ( not selected.isSet );
    select one s_dt related by s_irdt->S_DT[R17];
    select many s_dims from instances of S_DIM where false;
    cr_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
    relate cr_type to expr across R795.''defines type of'';
    // create creation
    create object instance cr of Creation;
    relate cr to expr across R776;
    select one obj related by act_cnv->O_OBJ[R672]->Class[R409.''is basis for''];
    relate cr to obj across R780.''creates'';
    select one class_file related by obj->File[R401];
    ::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
    
  else
  select one act_ctl related by act_smt->ACT_CTL[R603];
  if ( not_empty act_ctl )
    // create halt statement
    create object instance halt_smt of Halt;
    relate halt_smt to smt across R451;
    ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:"io.ciera.cairn.application.tasks.HaltExecutionTask", type:ImportType::IMPL );

  else
  select one act_del related by act_smt->ACT_DEL[R603];
  if ( not_empty act_del )
    // create delete statement
    create object instance del of DeleteSmt;
    relate del to smt across R451;
    // create variable reference expression
    create object instance expr of Expression;
    relate expr to smt across R775.''expressed within'';
    expr.expression_number = "1";
    relate del to expr across R462.''deletes instance specified by'';
    select one del_v_var related by act_del->V_VAR[R634];
    select one del_s_dt related by del_v_var->S_DT[R848];
    select one del_obj related by del_v_var->V_INT[R814]->O_OBJ[R818];
    del_s_dt = ::getInstRefTypeForClass( s_dt:del_s_dt, o_obj:del_obj );
    select many s_dims related by del_v_var->S_DIM[R849];
    del_type = TypeReference::getInstance( s_dt:del_s_dt, s_dims:s_dims );
    relate del_type to expr across R795.''defines type of'';
    select any del_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == del_v_var.Name );
    if ( not_empty del_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate del_var to var_ref across R782.''referenced through'';
      relate var_ref to expr across R776;
      select one type related by expr->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == del_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to expr across R776;
      self_ref.name = "this";
    else
      // TODO bad
    end if;

  else
  select one act_ret related by act_smt->ACT_RET[R603];
  if ( not_empty act_ret )
    // create return statement
    create object instance ret of ReturnSmt;
    relate ret to smt across R451;
    // create return expression
    select one ret_val related by act_ret->V_VAL[R668];
    if ( not_empty ret_val )
      ::transformExpression( v_val:ret_val, expr_number:"1", smt:smt );
      select any ret_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1" );
      relate ret_expr to ret across R473.''defines return value for'';
    end if;
  
  else
  select one act_rel related by act_smt->ACT_REL[R603];
  if ( not_empty act_rel )
    // create relate statement
    create object instance relsmt of RelateSmt;
    relate relsmt to smt across R451;
    // select the relationship
    select one r_rel related by act_rel->R_REL[R653];
    select one one_v_var related by act_rel->V_VAR[R615];
    select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
    select one one_class related by one_o_obj->Class[R409.''is basis for''];
    one_phrase = "";
    select one other_v_var related by act_rel->V_VAR[R616];
    select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
    select one other_class related by other_o_obj->Class[R409.''is basis for''];
    other_phrase = "";
    select one simp related by r_rel->R_SIMP[R206];
    if ( not_empty simp )
      if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
        other_phrase = C_UTIL::stripTics( s:act_rel.relationship_phrase );
        select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_rel.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
        if ( not_empty oir )
          one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
        else
          // TODO bad
        end if;
      else // non-reflexive simple association
        select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
        select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
        if ( not_empty one_oir and not_empty other_oir )
          one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
          other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
        else
          // TODO bad
        end if;
      end if;
    else
      select one subsup related by r_rel->R_SUBSUP[R206];
      if ( not_empty subsup )
        one_phrase = "is_a";
        other_phrase = "is_a";
      end if;
    end if;
    select any form_v_var from instances of V_VAR where false;
    select any part_v_var from instances of V_VAR where false;
    select any form_obj from instances of O_OBJ where false;
    select any part_obj from instances of O_OBJ where false;
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
      select any rel related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
      if ( not_empty rel )
        form_v_var = one_v_var;
        form_obj = one_o_obj;
        part_v_var = other_v_var;
        part_obj = other_o_obj;
      else
        select any rel related by containing_comp_def->Relationship[R448.''maintains instances of'']
          where ( selected.num == r_rel.Numb and
            ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
        form_v_var = other_v_var;
        form_obj = other_o_obj;
        part_v_var = one_v_var;
        part_obj = one_o_obj;
      end if;
      if ( not_empty rel )
        relate rel to relsmt across R481.''created by'';
      else
        // TODO bad
      end if;
    else
      // TODO bad
    end if;
    // create variable reference expression for formalizer
    create object instance form_expr of Expression;
    relate form_expr to smt across R775.''expressed within'';
    form_expr.expression_number = "1";
    relate relsmt to form_expr across R479.''relates formalizing'';
    select one form_s_dt related by form_v_var->S_DT[R848];
    form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:form_obj );
    select many s_dims related by form_v_var->S_DIM[R849];
    form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims );
    relate form_type to form_expr across R795.''defines type of'';
    select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == form_v_var.Name );
    if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate form_var to var_ref across R782.''referenced through'';
      relate var_ref to form_expr across R776;
      select one type related by form_expr->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == form_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to form_expr across R776;
      self_ref.name = "this";
    else
      // TODO bad
    end if;
    // create variable reference expression for participant
    create object instance part_expr of Expression;
    relate part_expr to smt across R775.''expressed within'';
    part_expr.expression_number = "2";
    relate relsmt to part_expr across R480.''relates participating'';
    select one part_s_dt related by part_v_var->S_DT[R848];
    part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:part_obj );
    select many s_dims related by part_v_var->S_DIM[R849];
    part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
    relate part_type to part_expr across R795.''defines type of'';
    select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == part_v_var.Name );
    if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate part_var to var_ref across R782.''referenced through'';
      relate var_ref to part_expr across R776;
      select one type related by part_expr->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == part_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to part_expr across R776;
      self_ref.name = "this";
    else
      // TODO bad
    end if;
 
  else
  select one act_ru related by act_smt->ACT_RU[R603];
  if ( not_empty act_ru )
    // select the relationship
    select one r_rel related by act_ru->R_REL[R654];
    select one one_v_var related by act_ru->V_VAR[R617];
    select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
    select one one_class related by one_o_obj->Class[R409.''is basis for''];
    one_phrase = "";
    select one other_v_var related by act_ru->V_VAR[R618];
    select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
    select one other_class related by other_o_obj->Class[R409.''is basis for''];
    other_phrase = "";
    select one link_v_var related by act_ru->V_VAR[R619];
    select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
    select one link_class related by link_o_obj->Class[R409.''is basis for''];
    select one simp related by r_rel->R_SIMP[R206];
    if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
      other_phrase = C_UTIL::stripTics( s:act_ru.relationship_phrase );
      select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_ru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
      select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
      select any one_oir from instances of R_OIR where false;
      for each oir in oirs
        if ( not_empty link and oir.OIR_ID != link.OIR_ID )
          one_oir = oir;
          one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
          break;
        end if;
      end for;
      if ( empty one_oir )
        // TODO bad
      end if;
    else // non-reflexive linked association
      select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
      select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
      if ( not_empty one_oir and not_empty other_oir )
        one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
        other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
      else
        // TODO bad
      end if;
    end if;
    select any rel1 from instances of Relationship where false;
    select any rel2 from instances of Relationship where false;
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
      select any rel1 related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
      select any rel2 related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
    else
      // TODO bad
    end if;
    if ( not_empty rel1 and not_empty rel2 )
      // create first relate statement (one to link)
      create object instance relsmt1 of RelateSmt;
      relate relsmt1 to smt across R451;
      relate rel1 to relsmt1 across R481.''created by'';
      // create variable reference expression for formalizer for the first relate
      create object instance form_expr1 of Expression;
      relate form_expr1 to smt across R775.''expressed within'';
      form_expr1.expression_number = "1";
      relate relsmt1 to form_expr1 across R479.''relates formalizing'';
      select one form_s_dt related by link_v_var->S_DT[R848];
      form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:link_o_obj );
      select many s_dims related by link_v_var->S_DIM[R849];
      form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims );
      relate form_type to form_expr1 across R795.''defines type of'';
      select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == link_v_var.Name );
      if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate form_var to var_ref across R782.''referenced through'';
        relate var_ref to form_expr1 across R776;
        select one type related by form_expr1->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == link_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to form_expr1 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create variable reference expression for participant for the first relate
      create object instance part_expr1 of Expression;
      relate part_expr1 to smt across R775.''expressed within'';
      part_expr1.expression_number = "2";
      relate relsmt1 to part_expr1 across R480.''relates participating'';
      select one part_s_dt related by one_v_var->S_DT[R848];
      part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:one_o_obj );
      select many s_dims related by one_v_var->S_DIM[R849];
      part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
      relate part_type to part_expr1 across R795.''defines type of'';
      select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == one_v_var.Name );
      if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate part_var to var_ref across R782.''referenced through'';
        relate var_ref to part_expr1 across R776;
        select one type related by part_expr1->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == one_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to part_expr1 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create second relate statement (other to link)
      create object instance smt2 of Statement;
      relate smt2 to block across R450.''is contained by'';
      smt2.statement_number = STR::itoa( i:STR::atoi( s:smt.statement_number ) + 1 );
      relate smt2 to smt across R477.''executes after'';
      smt2.oal = "";
      create object instance relsmt2 of RelateSmt;
      relate relsmt2 to smt2 across R451;
      relate rel2 to relsmt2 across R481.''created by'';
      // create variable reference expression for formalizer for the second relate
      create object instance form_expr2 of Expression;
      relate form_expr2 to smt2 across R775.''expressed within'';
      form_expr2.expression_number = "1";
      relate relsmt2 to form_expr2 across R479.''relates formalizing'';
      relate form_type to form_expr2 across R795.''defines type of'';
      select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == link_v_var.Name );
      if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate form_var to var_ref across R782.''referenced through'';
        relate var_ref to form_expr2 across R776;
        select one type related by form_expr2->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == link_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to form_expr2 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create variable reference expression for participant for the second relate
      create object instance part_expr2 of Expression;
      relate part_expr2 to smt2 across R775.''expressed within'';
      part_expr2.expression_number = "2";
      relate relsmt2 to part_expr2 across R480.''relates participating'';
      select one part_s_dt related by other_v_var->S_DT[R848];
      part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:other_o_obj );
      select many s_dims related by other_v_var->S_DIM[R849];
      part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
      relate part_type to part_expr2 across R795.''defines type of'';
      select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == other_v_var.Name );
      if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate part_var to var_ref across R782.''referenced through'';
        relate var_ref to part_expr2 across R776;
        select one type related by part_expr2->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == other_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to part_expr2 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
    else
      // TODO bad
    end if;
 
  else
  select one act_unr related by act_smt->ACT_UNR[R603];
  if ( not_empty act_unr )
    // create unrelate statement
    create object instance unrelsmt of UnrelateSmt;
    relate unrelsmt to smt across R451;
    // select the relationship
    select one r_rel related by act_unr->R_REL[R655];
    select one one_v_var related by act_unr->V_VAR[R620];
    select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
    select one one_class related by one_o_obj->Class[R409.''is basis for''];
    one_phrase = "";
    select one other_v_var related by act_unr->V_VAR[R621];
    select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
    select one other_class related by other_o_obj->Class[R409.''is basis for''];
    other_phrase = "";
    select one simp related by r_rel->R_SIMP[R206];
    if ( not_empty simp )
      if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
        other_phrase = C_UTIL::stripTics( s:act_unr.relationship_phrase );
        select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_unr.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
        if ( not_empty oir )
          one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
        else
          // TODO bad
        end if;
      else // non-reflexive simple association
        select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
        select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
        if ( not_empty one_oir and not_empty other_oir )
          one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
          other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
        else
          // TODO bad
        end if;
      end if;
    else
      select one subsup related by r_rel->R_SUBSUP[R206];
      if ( not_empty subsup )
        one_phrase = "is_a";
        other_phrase = "is_a";
      end if;
    end if;
    select any form_v_var from instances of V_VAR where false;
    select any part_v_var from instances of V_VAR where false;
    select any form_obj from instances of O_OBJ where false;
    select any part_obj from instances of O_OBJ where false;
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
      select any rel related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
      if ( not_empty rel )
        form_v_var = one_v_var;
        form_obj = one_o_obj;
        part_v_var = other_v_var;
        part_obj = other_o_obj;
      else
        select any rel related by containing_comp_def->Relationship[R448.''maintains instances of'']
          where ( selected.num == r_rel.Numb and
            ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
        form_v_var = other_v_var;
        form_obj = other_o_obj;
        part_v_var = one_v_var;
        part_obj = one_o_obj;
      end if;
      if ( not_empty rel )
        relate rel to unrelsmt across R484.''deleted by'';
      else
        // TODO bad
      end if;
    else
      // TODO bad
    end if;
    // create variable reference expression for formalizer
    create object instance form_expr of Expression;
    relate form_expr to smt across R775.''expressed within'';
    form_expr.expression_number = "1";
    relate unrelsmt to form_expr across R483.''unrelates formalizing'';
    select one form_s_dt related by form_v_var->S_DT[R848];
    form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:form_obj );
    select many s_dims related by form_v_var->S_DIM[R849];
    form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims );
    relate form_type to form_expr across R795.''defines type of'';
    select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == form_v_var.Name );
    if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate form_var to var_ref across R782.''referenced through'';
      relate var_ref to form_expr across R776;
      select one type related by form_expr->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == form_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to form_expr across R776;
      self_ref.name = "this";
    else
      // TODO bad
    end if;
    // create variable reference expression for participant
    create object instance part_expr of Expression;
    relate part_expr to smt across R775.''expressed within'';
    part_expr.expression_number = "2";
    relate unrelsmt to part_expr across R482.''unrelates participating'';
    select one part_s_dt related by part_v_var->S_DT[R848];
    part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:part_obj );
    select many s_dims related by part_v_var->S_DIM[R849];
    part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
    relate part_type to part_expr across R795.''defines type of'';
    select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == part_v_var.Name );
    if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate part_var to var_ref across R782.''referenced through'';
      relate var_ref to part_expr across R776;
      select one type related by part_expr->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == part_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to part_expr across R776;
      self_ref.name = "this";
    else
      // TODO bad
    end if;

  else
  select one act_uru related by act_smt->ACT_URU[R603];
  if ( not_empty act_uru )
    // select the relationship
    select one r_rel related by act_uru->R_REL[R656];
    select one one_v_var related by act_uru->V_VAR[R622];
    select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
    select one one_class related by one_o_obj->Class[R409.''is basis for''];
    one_phrase = "";
    select one other_v_var related by act_uru->V_VAR[R623];
    select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
    select one other_class related by other_o_obj->Class[R409.''is basis for''];
    other_phrase = "";
    select one link_v_var related by act_uru->V_VAR[R624];
    select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
    select one link_class related by link_o_obj->Class[R409.''is basis for''];
    select one simp related by r_rel->R_SIMP[R206];
    if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
      other_phrase = C_UTIL::stripTics( s:act_uru.relationship_phrase );
      select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_uru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
      select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
      select any one_oir from instances of R_OIR where false;
      for each oir in oirs
        if ( not_empty link and oir.OIR_ID != link.OIR_ID )
          one_oir = oir;
          one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
          break;
        end if;
      end for;
      if ( empty one_oir )
        // TODO bad
      end if;
    else // non-reflexive linked association
      select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
      select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
      if ( not_empty one_oir and not_empty other_oir )
        one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
        other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
      else
        // TODO bad
      end if;
    end if;
    select any rel1 from instances of Relationship where false;
    select any rel2 from instances of Relationship where false;
    containing_comp_def = ::getCompDefForStatement( smt:smt );
    if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
      select any rel1 related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
      select any rel2 related by containing_comp_def->Relationship[R448.''maintains instances of'']
        where ( selected.num == r_rel.Numb and
          ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
    else
      // TODO bad
    end if;
    if ( not_empty rel1 and not_empty rel2 )
      // create first unrelate statement (one to link)
      create object instance unrelsmt1 of UnrelateSmt;
      relate unrelsmt1 to smt across R451;
      relate rel1 to unrelsmt1 across R484.''deleted by'';
      // create variable reference expression for formalizer for the first unrelate
      create object instance form_expr1 of Expression;
      relate form_expr1 to smt across R775.''expressed within'';
      form_expr1.expression_number = "1";
      relate unrelsmt1 to form_expr1 across R483.''unrelates formalizing'';
      select one form_s_dt related by link_v_var->S_DT[R848];
      form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:link_o_obj );
      select many s_dims related by link_v_var->S_DIM[R849];
      form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims );
      relate form_type to form_expr1 across R795.''defines type of'';
      select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == link_v_var.Name );
      if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate form_var to var_ref across R782.''referenced through'';
        relate var_ref to form_expr1 across R776;
        select one type related by form_expr1->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == link_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to form_expr1 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create variable reference expression for participant for the first relate
      create object instance part_expr1 of Expression;
      relate part_expr1 to smt across R775.''expressed within'';
      part_expr1.expression_number = "2";
      relate unrelsmt1 to part_expr1 across R482.''unrelates participating'';
      select one part_s_dt related by one_v_var->S_DT[R848];
      part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:one_o_obj );
      select many s_dims related by one_v_var->S_DIM[R849];
      part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
      relate part_type to part_expr1 across R795.''defines type of'';
      select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == one_v_var.Name );
      if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate part_var to var_ref across R782.''referenced through'';
        relate var_ref to part_expr1 across R776;
        select one type related by part_expr1->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == one_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to part_expr1 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create second relate statement (other to link)
      create object instance smt2 of Statement;
      relate smt2 to block across R450.''is contained by'';
      smt2.statement_number = STR::itoa( i:STR::atoi( s:smt.statement_number ) + 1 );
      relate smt2 to smt across R477.''executes after'';
      smt2.oal = "";
      create object instance unrelsmt2 of UnrelateSmt;
      relate unrelsmt2 to smt2 across R451;
      relate rel2 to unrelsmt2 across R484.''deleted by'';
      // create variable reference expression for formalizer for the second relate
      create object instance form_expr2 of Expression;
      relate form_expr2 to smt2 across R775.''expressed within'';
      form_expr2.expression_number = "1";
      relate unrelsmt2 to form_expr2 across R483.''unrelates formalizing'';
      relate form_type to form_expr2 across R795.''defines type of'';
      select any form_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == link_v_var.Name );
      if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate form_var to var_ref across R782.''referenced through'';
        relate var_ref to form_expr2 across R776;
        select one type related by form_expr2->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == link_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to form_expr2 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
      // create variable reference expression for participant for the second relate
      create object instance part_expr2 of Expression;
      relate part_expr2 to smt2 across R775.''expressed within'';
      part_expr2.expression_number = "2";
      relate unrelsmt2 to part_expr2 across R482.''unrelates participating'';
      select one part_s_dt related by other_v_var->S_DT[R848];
      part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:other_o_obj );
      select many s_dims related by other_v_var->S_DIM[R849];
      part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims );
      relate part_type to part_expr2 across R795.''defines type of'';
      select any part_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == other_v_var.Name );
      if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
        create object instance var_ref of VariableReference;
        relate part_var to var_ref across R782.''referenced through'';
        relate var_ref to part_expr2 across R776;
        select one type related by part_expr2->TypeReference[R795]->Type[R3800];
        ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
      elif ( "self" == other_v_var.Name )
        // create named reference
        create object instance self_ref of NamedReference;
        relate self_ref to part_expr2 across R776;
        self_ref.name = "this";
      else
        // TODO bad
      end if;
    else
      // TODO bad
    end if;
 
  else
    LOG::LogInfo( message:"statement type not yet supported" );
  end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if;

else
  // TODO bad

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e6de2932-eaf3-4f5d-a37a-9c86f8c8fa3d",
	"32c6aeb5-838d-4564-a401-ffc6720e4e0c",
	'act_smt',
	"8ca0ad46-f8b8-47ba-9456-548bf0777490",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8ca0ad46-f8b8-47ba-9456-548bf0777490",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("7c646715-082c-40f2-96ff-eb2028097a2c",
	"32c6aeb5-838d-4564-a401-ffc6720e4e0c",
	'block',
	"e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	0,
	'',
	"e6de2932-eaf3-4f5d-a37a-9c86f8c8fa3d",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Code Block>',
	'',
	'',
	'../architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("41c4eee6-42be-46ce-8460-3fd5c66541ff",
	"32c6aeb5-838d-4564-a401-ffc6720e4e0c",
	'prev_smt',
	"056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	0,
	'',
	"7c646715-082c-40f2-96ff-eb2028097a2c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../architecture/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("32c6aeb5-838d-4564-a401-ffc6720e4e0c",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a8ec0a61-3784-4612-8238-859ed7537299",
	"00000000-0000-0000-0000-000000000000",
	'transformExpression',
	'',
	'v_val = param.v_val;
smt = param.smt;

// create expression
create object instance expr of Expression;
relate expr to smt across R775.''expressed within'';
expr.expression_number = param.expr_number;

// link type
select one s_dt related by v_val->S_DT[R820];
select many s_dims from instances of S_DIM where false;
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to expr across R795.''defines type of'';

select one v_lst related by v_val->V_LST[R801];
if ( not_empty v_lst )
  // create literal
  create object instance lit of Literal;
  relate lit to expr across R776;
  lit.value = v_lst.Value;
  ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:"io.ciera.summit.types.XtumlString", type:ImportType::IMPL );

else
select one v_lbo related by v_val->V_LBO[R801];
if ( not_empty v_lbo )
  // create literal
  create object instance lit of Literal;
  relate lit to expr across R776;
  if ( "true" == T::l( s:v_lbo.Value ) )
    lit.value = "true";
  else
    lit.value = "false";
  end if;

else
select one v_lin related by v_val->V_LIN[R801];
if ( not_empty v_lin )
  // create literal
  create object instance lit of Literal;
  relate lit to expr across R776;
  lit.value = v_lin.Value;

else
select one v_lrl related by v_val->V_LRL[R801];
if ( not_empty v_lrl )
  // create literal
  create object instance lit of Literal;
  relate lit to expr across R776;
  lit.value = v_lrl.Value;

else
select one v_len related by v_val->V_LEN[R801];
if ( not_empty v_len )
  // create enumerator reference
  create object instance enum_ref of EnumeratorReference;
  relate enum_ref to expr across R776;
  select one s_enum related by v_len->S_ENUM[R824];
  select any enumer related by s_enum->S_EDT[R27]->S_DT[R17]->Type[R423.''is basis of'']->EnumeratedType[R407]->Enumerator[R415.''declares''] where ( selected.name == T::u( s:s_enum.Name ) );
  if ( not_empty enumer )
    select one edt_file related by enumer->EnumeratedType[R415.''is unique value of'']->File[R401];
    ::addFileToImports( file: ::getFileForStatement( smt:smt ), file_to_import:edt_file, type:ImportType::IMPL );
    relate enumer to enum_ref across R786.''is referenced by'';
  else
    // TODO bad
  end if;

else
select one v_tvl related by v_val->V_TVL[R801];
if ( not_empty v_tvl )
  // if this is the first location, create a new variable
  select one v_var related by v_tvl->V_VAR[R805];
  select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
  if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
    ::transformVariable( v_var:v_var, smt:smt );
  end if;

  // create variable reference
  select any var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
  create object instance var_ref of VariableReference;
  relate var to var_ref across R782.''referenced through'';
  relate var_ref to expr across R776;
  // add type reference to file
  select one expr_type related by var->TypeReference[R461]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );

else
select one v_irf related by v_val->V_IRF[R801];
if ( not_empty v_irf )
  // if this is the first location, create a new variable
  select one v_var related by v_irf->V_VAR[R808];
  if ( "self" == T::l( s:v_var.Name ) ) // reference to self
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to expr across R776;
    self_ref.name = "this";
  else
    select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
    if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
      ::transformVariable( v_var:v_var, smt:smt );
    end if;
    // create variable reference
    select any var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
    create object instance var_ref of VariableReference;
    relate var to var_ref across R782.''referenced through'';
    relate var_ref to expr across R776;
    // add type reference to file
    select one expr_type related by var->TypeReference[R461]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
  end if;

else
select one v_isr related by v_val->V_ISR[R801];
if ( not_empty v_isr )
  // if this is the first location, create a new variable
  select one v_var related by v_isr->V_VAR[R809];
  select any existing_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
  if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
    ::transformVariable( v_var:v_var, smt:smt );
  end if;

  // create variable reference
  select any var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == v_var.Name );
  create object instance var_ref of VariableReference;
  relate var to var_ref across R782.''referenced through'';
  relate var_ref to expr across R776;
  // add type reference to file
  select one expr_type related by var->TypeReference[R461]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
  
else
select one v_avl related by v_val->V_AVL[R801];
if ( not_empty v_avl )
  create object instance acc of AttributeAccess;
  relate acc to expr across R776;
  select one root_val related by v_avl->V_VAL[R807];
  ::transformExpression( v_val:root_val, expr_number:expr.expression_number + ".1", smt:smt );
  select any root_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".1" );
  relate root_expr to acc across R785.''is used as basis for'';
  select one attr related by v_avl->O_ATTR[R806]->Attribute[R414];
  relate attr to acc across R788.''is referenced by'';

else
select one v_pvl related by v_val->V_PVL[R801];
if ( not_empty v_pvl )
  create object instance ref of ParameterReference;
  relate ref to expr across R776;
  param_name = "";
  select one brg_param related by v_pvl->S_BPARM[R831];
  if ( not_empty brg_param ) param_name = brg_param.Name; else
  select one fnc_param related by v_pvl->S_SPARM[R832];
  if ( not_empty fnc_param ) param_name = fnc_param.Name; else
  select one op_param related by v_pvl->O_TPARM[R833];
  if ( not_empty op_param ) param_name = op_param.Name; else
  select one ep_param related by v_pvl->C_PP[R843];
  if ( not_empty ep_param ) param_name = ep_param.Name;
  else
    // TODO bad
  end if; end if; end if; end if;
  select any formal_param related by smt->CodeBlock[R450.''is contained by'']->InvocableObject[R4000.''is invoked in'']->FormalParameter[R429.''declares signature with'']
    where ( selected.name == "p_" + param_name );
  if ( not_empty formal_param )
    relate formal_param to ref across R781;
  else
    // TODO bad
  end if;

else
select one v_brv related by v_val->V_BRV[R801];
if ( not_empty v_brv )
  select one util_func related by v_brv->S_BRG[R828]->UtilityFunction[R4570.''is basis for''];
  if ( empty util_func )
    select one s_ee related by v_brv->S_BRG[R828]->S_EE[R19];
    select one s_ee_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
    select any empty_comp_def from instances of ComponentDefinition where false;
    ::transformUtility( s_ee:s_ee, ep_pkg:s_ee_pkg, containing_comp_def:empty_comp_def, exclude:true, path: ::ep_pkgToPath( ep_pkg:s_ee_pkg ) );
    select one util_func related by v_brv->S_BRG[R828]->UtilityFunction[R4570.''is basis for''];
  end if;
  select one invocable related by util_func->InvocableObject[R427];
  select one utility related by util_func->Utility[R4559.''provided by''];
  select one utility_file related by utility->File[R401];
  containing_comp_def = ::getCompDefForStatement( smt:smt );
  select one containing_comp_file related by containing_comp_def->File[R401];
  ::addFileToImports( file:containing_comp_file, file_to_import:utility_file, type:ImportType::IMPL );
  ::addStringToImports( file:containing_comp_file, s: ::pathToPackage( path:utility_file.path ) + ".impl." + utility_file.name + "Impl", type:ImportType::IMPL );
  if ( not_empty containing_comp_def )
    select any util_ref related by utility->UtilityReference[R4558] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
    if ( empty util_ref )
      create object instance util_ref of UtilityReference;
      relate utility to containing_comp_def across R4558.''used within context of'' using util_ref;
    end if;
  end if;
  if ( not_empty invocable )
    // create invocation
    create object instance invoc of Invocation;
    relate invoc to expr across R776;
    relate invoc to invocable across R792;
    // create named reference expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775.''expressed within'';
    expr2.expression_number = expr.expression_number + ".1";
    void_type = TypeReference::getBuiltinTypeReference( name:"void" );
    relate void_type to expr2 across R795;
    // create named reference
    create object instance named_ref of NamedReference;
    relate named_ref to expr2 across R776;
    relate expr2 to invoc across R798.''is used as basis for'';
    named_ref.name = "context()." + utility.name + "()";
    // transform actual parameters
    select many v_pars related by v_brv->V_PAR[R810];
    ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:expr.expression_number, base_num:2 );
  else
    // TODO bad
  end if;

else
select one v_fnv related by v_val->V_FNV[R801];
if ( not_empty v_fnv )
  select one s_sync related by v_fnv->S_SYNC[R827];
  containing_comp_def = ::getCompDefForStatement( smt:smt );
  select any invocable related by containing_comp_def->Function[R405.''provides synchronous'']->InvocableObject[R427] where ( selected.name == s_sync.Name );
  if ( not_empty invocable )
    // create invocation
    create object instance invoc of Invocation;
    relate invoc to expr across R776;
    relate invoc to invocable across R792;
    // create named reference expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775.''expressed within'';
    expr2.expression_number = expr.expression_number + ".1";
    void_type = TypeReference::getBuiltinTypeReference( name:"void" );
    relate void_type to expr2 across R795;
    // create named reference
    create object instance named_ref of NamedReference;
    relate named_ref to expr2 across R776;
    relate expr2 to invoc across R798.''is used as basis for'';
    named_ref.name = "context()";
    // transform actual parameters
    select many v_pars related by v_fnv->V_PAR[R817];
    ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:expr.expression_number, base_num:2 );
  else
    // TODO bad
  end if;

else
select one v_trv related by v_val->V_TRV[R801];
if ( not_empty v_trv )
  select one o_tfr related by v_trv->O_TFR[R829];
  select any invocable related by o_tfr->O_OBJ[R115]->Class[R409]->Operation[R416.''provides'']->InvocableObject[R427] where ( selected.name == o_tfr.Name );
  if ( not_empty invocable )
    // create invocation
    create object instance invoc of Invocation;
    relate invoc to expr across R776;
    relate invoc to invocable across R792;
    // relate expression to expression as statement
    if ( Scope::Instance == o_tfr.Instance_Based )
      select one op_v_var related by v_trv->V_VAR[R830];
      if ( not_empty op_v_var ) // instance based operation
        // create variable reference expression
        create object instance expr2 of Expression;
        relate expr2 to smt across R775.''expressed within'';
        expr2.expression_number = expr.expression_number + ".1";
        relate expr2 to invoc across R798.''is used as basis for'';
        select one op_s_dt related by op_v_var->S_DT[R848];
        select one op_obj related by o_tfr->O_OBJ[R115];
        op_s_dt = ::getInstRefTypeForClass( s_dt:op_s_dt, o_obj:op_obj );
        select many s_dims related by op_v_var->S_DIM[R849];
        op_type = TypeReference::getInstance( s_dt:op_s_dt, s_dims:s_dims );
        relate op_type to expr2 across R795.''defines type of'';
        select any op_var related by smt->CodeBlock[R450.''is contained by'']->Variable[R458.''has in scope''] where ( selected.name == op_v_var.Name );
        if ( not_empty op_var ) // cannot declare two variables of the same name in the same scope
          create object instance var_ref of VariableReference;
          relate op_var to var_ref across R782.''referenced through'';
          relate var_ref to expr2 across R776;
          // add type reference to file
          select one expr_type related by expr2->TypeReference[R795]->Type[R3800];
          ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
        elif ( "self" == op_v_var.Name )
          // create named reference
          create object instance self_ref of NamedReference;
          relate self_ref to expr2 across R776;
          self_ref.name = "this";
        else
          // TODO bad
        end if;
      else // must be a selected reference
        // create named reference expression
        create object instance expr2 of Expression;
        relate expr2 to smt across R775.''expressed within'';
        expr2.expression_number = expr.expression_number + ".1";
        relate expr2 to invoc across R798.''is used as basis for'';
        select any s_irdt related by o_tfr->O_OBJ[R115]->S_IRDT[R123] where ( not selected.isSet );
        select one s_dt related by s_irdt->S_DT[R17];
        select many s_dims from instances of S_DIM where false;
        op_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
        relate op_type to expr2 across R795.''defines type of'';
        // create selected reference
        create object instance sel of SelectedExpr;
        relate sel to expr2 across R776;
      end if;
    else // class based operation
      // create named reference expression
      create object instance expr2 of Expression;
      relate expr2 to smt across R775.''expressed within'';
      expr2.expression_number = expr.expression_number + ".1";
      relate expr2 to invoc across R798.''is used as basis for'';
      void_type = TypeReference::getBuiltinTypeReference( name:"void" );
      relate void_type to expr2 across R795;
      // create named reference
      create object instance named_ref of NamedReference;
      relate named_ref to expr2 across R776;
      select one target_class related by invocable->Operation[R427]->Class[R416.''provided by''];
      named_ref.name = "new " + target_class.name + "Impl.CLASS(context())";
      select one class_file related by target_class->File[R401];
      ::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
    end if;
    // transform actual parameters
    select many v_pars related by v_trv->V_PAR[R811];
    ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:expr.expression_number, base_num:2 );
  else
    // TODO bad
  end if;

else
select one v_slr related by v_val->V_SLR[R801];
if ( not_empty v_slr )
  // create selected reference
  create object instance sel of SelectedExpr;
  relate sel to expr across R776;

else
select one v_uny related by v_val->V_UNY[R801];
if ( not_empty v_uny )
  // create the unary expression
  create object instance unary of UnaryOperation;
  relate unary to expr across R776;
  select one op_val related by v_uny->V_VAL[R804];
  if ( "not_empty" == T::l( s:v_uny.Operator ) ) // create an additional ''not'' expression before transforming an ''empty'' expression
    unary.operator = "!";
    unary.invocation = false;
    // create ''empty'' expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775.''expressed within'';
    expr2.expression_number = expr.expression_number + ".1";
    relate expr2 to unary across R777.''is single operand for'';
    boolean_type = TypeReference::getBuiltinTypeReference( name:"boolean" );
    relate boolean_type to expr2 across R795.''defines type of'';
    create object instance unary2 of UnaryOperation;
    relate unary2 to expr2 across R776;
    unary2.operator = "isEmpty";
    unary2.invocation = true;
    // transform the operatnd expression
    ::transformExpression( v_val:op_val, expr_number:expr2.expression_number + ".1", smt:smt );
    select any op_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr2.expression_number + ".1" );
    relate op_expr to unary2 across R777.''is single operand for'';
  else
    if ( "not" == T::l( s:v_uny.Operator ) )
      unary.operator = "!";
      unary.invocation = false;
    elif ( "empty" == T::l( s:v_uny.Operator ) )
      unary.operator = "isEmpty";
      unary.invocation = true;
    elif ( "cardinality" == T::l( s:v_uny.Operator ) )
      unary.operator = "size";
      unary.invocation = true;
    elif ( ( "+" == T::l( s:v_uny.Operator ) ) or ( "-" == T::l( s:v_uny.Operator ) ) )
      unary.operator = v_uny.Operator;
      unary.invocation = false;
    else
      // TODO bad
    end if;
    // transform the operatnd expression
    ::transformExpression( v_val:op_val, expr_number:expr.expression_number + ".1", smt:smt );
    select any op_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".1" );
    relate op_expr to unary across R777.''is single operand for'';
  end if;

else
select one v_bin related by v_val->V_BIN[R801];
if ( not_empty v_bin )
  // create the binary expression
  create object instance binary of BinaryOperation;
  relate binary to expr across R776;
  select one l_val related by v_bin->V_VAL[R802];
  select one r_val related by v_bin->V_VAL[R803];
  select one l_s_dt related by l_val->S_DT[R820];
  select one l_type related by l_s_dt->Type[R423.''is basis of''];
  select one l_set related by l_type->ClassSet[R407];
  // translate the operator
  if ( "and" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "&&";
      binary.invocation = false;
    else
      binary.operator = "and";
      binary.invocation = true;
    end if;
  elif ( "or" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "||";
      binary.invocation = false;
    else
      binary.operator = "or";
      binary.invocation = true;
    end if;
  elif ( "==" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "==";
      binary.invocation = false;
    else
      binary.operator = "equality";
      binary.invocation = true;
    end if;
  elif ( "!=" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "!=";
      binary.invocation = false;
    else
      binary.operator = "inequality";
      binary.invocation = true;
    end if;
  elif ( "<" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "<";
      binary.invocation = false;
    else
      binary.operator = "lessThan";
      binary.invocation = true;
    end if;
  elif ( "<=" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "<=";
      binary.invocation = false;
    else
      binary.operator = "lessThanOrEqual";
      binary.invocation = true;
    end if;
  elif ( ">" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = ">";
      binary.invocation = false;
    else
      binary.operator = "greaterThan";
      binary.invocation = true;
    end if;
  elif ( ">=" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = ">=";
      binary.invocation = false;
    else
      binary.operator = "greaterThanOrEqual";
      binary.invocation = true;
    end if;
  elif ( "+" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "+";
      binary.invocation = false;
    else
      if ( not_empty l_set ) // set type
        binary.operator = "union";
      elif ( "XtumlString" == l_type.name and "io.ciera.summit.types" == l_type.package )
        // TODO handle concatenation for UDTs based on string
        binary.operator = "concat";
      else
        binary.operator = "add";
      end if;
      binary.invocation = true;
    end if;
  elif ( "-" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "-";
      binary.invocation = false;
    else
      if ( not_empty l_set ) // set type
        binary.operator = "difference";
      else
        binary.operator = "subtract";
      end if;
      binary.invocation = true;
    end if;
  elif ( "*" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "*";
      binary.invocation = false;
    else
      binary.operator = "multiply";
      binary.invocation = true;
    end if;
  elif ( "/" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "/";
      binary.invocation = false;
    else
      binary.operator = "divide";
      binary.invocation = true;
    end if;
  elif ( "%" == T::l( s:v_bin.Operator ) )
    if ( l_type.primitive() )
      binary.operator = "%";
      binary.invocation = false;
    else
      binary.operator = "remainder";
      binary.invocation = true;
    end if;
  elif ( "|" == T::l( s:v_bin.Operator ) )
    binary.operator = "union";
    binary.invocation = true;
  elif ( "&" == T::l( s:v_bin.Operator ) )
    binary.operator = "intersection";
    binary.invocation = true;
  elif ( "^" == T::l( s:v_bin.Operator ) )
    binary.operator = "disunion";
    binary.invocation = true;
  end if;
  // translate the left operand
  if ( ::precedenceCheck( val1:l_val, val2:v_val ) < 0 ) // if the left operand is lower precedence than the current operator, force it to be evaluated first with parentheses
    // transform the left hand expression
    ::transformExpression( v_val:l_val, expr_number:expr.expression_number + ".1.1", smt:smt );
    select any paren_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".1.1" );
    // create the parenthesis
    create object instance l_expr of Expression;
    relate l_expr to smt across R775.''expressed within'';
    l_expr.expression_number = expr.expression_number + ".1";
    select one l_type_ref related by paren_expr->TypeReference[R795];
    relate l_type_ref to l_expr across R795.''defines type of'';
    create object instance l_paren of ParenthesizedExpression;
    relate l_paren to l_expr across R776;
    relate l_expr to binary across R779.''is left operand for'';
    relate paren_expr to l_paren across R784.''is wrapped in parentheses by'';
  else
    // transform the left hand expression
    ::transformExpression( v_val:l_val, expr_number:expr.expression_number + ".1", smt:smt );
    select any l_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".1" );
    relate l_expr to binary across R779.''is left operand for'';
  end if;
  // translate the right operand
  if ( ::precedenceCheck( val1:r_val, val2:v_val ) < 0 ) // if the right operand is lower precedence than the current operator, force it to be evaluated first with parentheses
    // transform the right hand expression
    ::transformExpression( v_val:r_val, expr_number:expr.expression_number + ".2.1", smt:smt );
    select any paren_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".2.1" );
    // create the parenthesis
    create object instance r_expr of Expression;
    relate r_expr to smt across R775.''expressed within'';
    r_expr.expression_number = expr.expression_number + ".2";
    select one r_s_dt related by r_val->S_DT[R820];
    select one r_type_ref related by paren_expr->TypeReference[R795];
    relate r_type_ref to r_expr across R795.''defines type of'';
    create object instance r_paren of ParenthesizedExpression;
    relate r_paren to r_expr across R776;
    relate r_expr to binary across R778.''is right operand for'';
    relate paren_expr to r_paren across R784.''is wrapped in parentheses by'';
  else
    // transform the right hand expression
    ::transformExpression( v_val:r_val, expr_number:expr.expression_number + ".2", smt:smt );
    select any r_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".2" );
    relate r_expr to binary across R778.''is right operand for'';
  end if;

else
select one v_aer related by v_val->V_AER[R801];
if ( not_empty v_aer )
  // transform root expression
  select one root_val related by v_aer->V_VAL[R838];
  ::transformExpression( v_val:root_val, expr_number:expr.expression_number + ".1", smt:smt );
  select any root_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".1" );
  // transform index expression
  select one index_val related by v_aer->V_VAL[R839];
  ::transformExpression( v_val:index_val, expr_number:expr.expression_number + ".2", smt:smt );
  select any index_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr.expression_number + ".2" );
  // create array element reference
  create object instance array_ref of ArrayElementReference;
  relate array_ref to expr across R776;
  relate array_ref to root_expr across R3900;
  relate array_ref to index_expr across R3901;

else
  LOG::LogInfo( message:"expression type not yet supported" );
end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e59210d7-9cfa-4283-9165-399cf318f85a",
	"a8ec0a61-3784-4612-8238-859ed7537299",
	'v_val',
	"5400d269-ee31-4742-ac70-8532512a854c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5400d269-ee31-4742-ac70-8532512a854c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Value>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("4d557abc-fa3b-4ac5-9535-931b617dea74",
	"a8ec0a61-3784-4612-8238-859ed7537299",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e59210d7-9cfa-4283-9165-399cf318f85a",
	'');
INSERT INTO S_SPARM
	VALUES ("2511f4b9-1b4e-446e-b4c2-28b2e1dff2f8",
	"a8ec0a61-3784-4612-8238-859ed7537299",
	'smt',
	"056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	0,
	'',
	"4d557abc-fa3b-4ac5-9535-931b617dea74",
	'');
INSERT INTO PE_PE
	VALUES ("a8ec0a61-3784-4612-8238-859ed7537299",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a0f73479-987f-4bb5-9986-1578bf4c46ec",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameter',
	'',
	'invocation = param.invocation;
parm = param.parm;
v_par = param.v_par;
expr_number = param.expression_num;

select one smt related by invocation->Expression[R776]->Statement[R775.''expressed within''];

select any expr from instances of Expression where false;

select one v_val related by v_par->V_VAL[R800];
if ( not_empty v_val )
  ::transformExpression( v_val:v_val, expr_number:expr_number, smt:smt );
  select any expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr_number );
else
  // TODO bad
end if;

if ( not_empty expr )

  // create the actual parameter
  create object instance act_parm of ActualParameter;
  relate act_parm to expr across R794.''parameter value specified by'';
  relate invocation to parm across R793.''is provided data from'' using act_parm;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("faf34262-4a1c-4150-95a7-e111fcc9f93b",
	"a0f73479-987f-4bb5-9986-1578bf4c46ec",
	'invocation',
	"bf11e8b5-3fe2-4389-be6d-ff5c89b9ddf0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bf11e8b5-3fe2-4389-be6d-ff5c89b9ddf0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocation>',
	'',
	'',
	'../architecture/expression/expression.xtuml');
INSERT INTO S_SPARM
	VALUES ("321637ef-dfe6-4763-89fb-60a54c3d76a9",
	"a0f73479-987f-4bb5-9986-1578bf4c46ec",
	'parm',
	"a4048d05-d8f6-4f96-b1fc-79a73158a744",
	0,
	'',
	"faf34262-4a1c-4150-95a7-e111fcc9f93b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a4048d05-d8f6-4f96-b1fc-79a73158a744",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Formal Parameter>',
	'',
	'',
	'../architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("1da29959-3bd4-4d1f-93ed-cac7516f145d",
	"a0f73479-987f-4bb5-9986-1578bf4c46ec",
	'expression_num',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"321637ef-dfe6-4763-89fb-60a54c3d76a9",
	'');
INSERT INTO S_SPARM
	VALUES ("d5c2972f-55dd-4ea5-addb-29f83853f9c2",
	"a0f73479-987f-4bb5-9986-1578bf4c46ec",
	'v_par',
	"2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	0,
	'',
	"1da29959-3bd4-4d1f-93ed-cac7516f145d",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO PE_PE
	VALUES ("a0f73479-987f-4bb5-9986-1578bf4c46ec",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f646e3fa-6e55-4420-b552-196b12458e30",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameters',
	'',
	'invocation = param.invocation;
v_pars = param.v_pars;
expr_number = param.expr_number;
base_num = param.base_num;

// get first formal parameter
select any parm related by invocation->InvocableObject[R792]->FormalParameter[R429.''declares signature with''];
select one prev_parm related by parm->FormalParameter[R404.''follows''];
while ( not_empty prev_parm )
  parm = prev_parm;
  select one prev_parm related by parm->FormalParameter[R404.''follows''];
end while;

// transform each parameter
num = base_num;
select any v_par from instances of V_PAR where false;
while ( not_empty parm )
  for each par in v_pars
    if ( "p_" + par.Name == parm.name )
      v_par = par;
      break;
    end if;
  end for;
  ::transformActualParameter( invocation:invocation, parm:parm, expression_num:expr_number + "." + STR::itoa( i:num ), v_par:v_par );
  select one parm related by parm->FormalParameter[R404.''precedes''];
  num = num + 1;
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4534090f-233e-4933-b401-5f0e07410e52",
	"f646e3fa-6e55-4420-b552-196b12458e30",
	'invocation',
	"bf11e8b5-3fe2-4389-be6d-ff5c89b9ddf0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9f8418eb-510e-42ca-b1b6-15044048de73",
	"f646e3fa-6e55-4420-b552-196b12458e30",
	'v_pars',
	"cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	0,
	'',
	"4534090f-233e-4933-b401-5f0e07410e52",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("6ebfdc3a-59e4-4cdc-941f-d10dd63c2b63",
	"f646e3fa-6e55-4420-b552-196b12458e30",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9f8418eb-510e-42ca-b1b6-15044048de73",
	'');
INSERT INTO S_SPARM
	VALUES ("e5a3d96f-e659-4f34-b152-5405c0b160e3",
	"f646e3fa-6e55-4420-b552-196b12458e30",
	'base_num',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"6ebfdc3a-59e4-4cdc-941f-d10dd63c2b63",
	'');
INSERT INTO PE_PE
	VALUES ("f646e3fa-6e55-4420-b552-196b12458e30",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dcbd4997-dc06-45ba-af97-cd7cb131175e",
	"00000000-0000-0000-0000-000000000000",
	'transformBlock',
	'',
	'upper_block = param.upper_block;
act_blk = param.act_blk;
if ( not_empty act_blk )

  invocable = param.invocable;

  // create code block
  create object instance block of CodeBlock;
  if ( empty upper_block )
    block.top_level = true;
    block.tab_depth = 1;
    select one port_msg related by invocable->PortMessage[R427];
    if ( not_empty port_msg )
      select one port related by port_msg->Port[R420.''is implemented within''];
      select one msg related by port_msg->Message[R420.''provides implementation for''];
      if ( ( msg.to_provider and not port.provider ) or ( not msg.to_provider and port.provider ) )
        block.tab_depth = 2; // increase the tab depth by one for bodies which belong to outbound port messages
      end if;
    end if;
    select one deriv related by invocable->AttributeDerivation[R427];
    select one class_op related by invocable->Operation[R427] where ( selected.is_class_based );
    if ( not_empty deriv  or not_empty class_op )
      block.tab_depth = 2; // increase the tab depth by one for bodies which belong to derived attributes and class based operations
    end if;
  else
    select one invocable related by upper_block->InvocableObject[R4000.''is invoked in''];
    block.top_level = false;
    block.tab_depth = upper_block.tab_depth + 1;
  end if;
  relate block to invocable across R4000.''is invoked in'';
  block.block_number = param.block_number;

  // copy visibile variables from upper block
  select many vars related by upper_block->Variable[R458.''has in scope''];
  for each var in vars
    create object instance var_in_scope of VariableInScope;
    relate var to block across R458.''is in scope for'' using var_in_scope;
  end for;

  // transform all statements
  ::transformStatements( act_blk:act_blk, block:block );

  // handle symbol table manipulation for top level blocks
  select any var_ref related by block->Statement[R450.''is scope for'']->Expression[R775.''may contain'']->VariableReference[R776];
  if ( not_empty var_ref )
    select any top_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.top_level );
    // push a new symbol table at the beginning of the body
    indent = ::getIndent( tab_depth:top_block.tab_depth + 1 );
    if ( -1 == STR::indexof( haystack:top_block.prefix, needle:"pushSymbolTable" ) )
      top_block.prefix = indent + "pushSymbolTable();\n";
      // pop the symbol table at the very end
      top_block.suffix = indent + "popSymbolTable();\n";
      // if any return expression has a variable reference, create a temporary variable for the return value
    end if;
    select any return_var_ref related by block->Statement[R450.''is scope for'']->ReturnSmt[R451]->Statement[R451]->Expression[R775.''may contain'']->VariableReference[R776];
    if ( not_empty return_var_ref and -1 == STR::indexof( haystack:top_block.prefix, needle:"_return_value" ) )
      select one return_type related by invocable->TypeReference[R428.''return value is typed by''];
      top_block.prefix = indent + "final " + return_type.type_reference_name + " _return_value;\n" + top_block.prefix;
    end if;
  end if;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("d5291ef9-84b0-4e71-93b1-85310f657651",
	"dcbd4997-dc06-45ba-af97-cd7cb131175e",
	'upper_block',
	"e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	0,
	'',
	"00a1d887-1c67-4a49-9991-fed613891665",
	'');
INSERT INTO S_SPARM
	VALUES ("219af228-d78c-4c38-905c-dc5eda8dc21b",
	"dcbd4997-dc06-45ba-af97-cd7cb131175e",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"d5291ef9-84b0-4e71-93b1-85310f657651",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("069f7c9f-7387-4d78-8d66-5f72c773e58e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Block>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("bee5b5d3-f64a-42c6-a999-5a0d6a7f8ddd",
	"dcbd4997-dc06-45ba-af97-cd7cb131175e",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"219af228-d78c-4c38-905c-dc5eda8dc21b",
	'');
INSERT INTO S_SPARM
	VALUES ("00a1d887-1c67-4a49-9991-fed613891665",
	"dcbd4997-dc06-45ba-af97-cd7cb131175e",
	'invocable',
	"30c7a5ba-c6d9-44fd-8e61-f22cde8fdc41",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("dcbd4997-dc06-45ba-af97-cd7cb131175e",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("61ed9659-8b4f-4a3d-bfc2-02e931a0536c",
	"00000000-0000-0000-0000-000000000000",
	'transformBlockForElif',
	'',
	'upper_block = param.upper_block;
act_el = param.act_el;

// create block
select one invocable related by upper_block->InvocableObject[R4000.''is invoked in''];
create object instance block of CodeBlock;
relate block to invocable across R4000.''is invoked in'';
block.block_number = param.block_number;
block.tab_depth = upper_block.tab_depth;  // keep same tab depth

// copy visibile variables from upper block
select many vars related by upper_block->Variable[R458.''has in scope''];
for each var in vars
  create object instance var_in_scope of VariableInScope;
  relate var to block across R458.''is in scope for'' using var_in_scope;
end for;

// create single statement in block
create object instance smt of Statement;
relate smt to block across R450.''is contained by'';
smt.statement_number = "1";
select one body related by block->InvocableObject[R4000.''is invoked in''];
select one act_smt related by act_el->ACT_SMT[R603];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create if statement
create object instance if_smt of IfSmt;
relate if_smt to smt across R451;
if_smt.is_else_if = true;

// translate if expression
select one if_val related by act_el->V_VAL[R659];
::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
select any if_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == "1" );
relate if_expr to if_smt across R471.''determines execution of blocks for'';

// create then block
select any empty_invocable from instances of InvocableObject where false;
then_block_number = ::getNextBlockNumber( upper_block:block );
select one then_blk related by act_el->ACT_BLK[R658];
::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocable:empty_invocable );
select any then_block related by block->InvocableObject[R4000.''is invoked in'']->CodeBlock[R4000.''has''] where ( selected.block_number == then_block_number );
relate then_block to if_smt across R453.''controls then for'';',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("ee627ef3-1723-44c4-86f5-011942e8a178",
	"61ed9659-8b4f-4a3d-bfc2-02e931a0536c",
	'upper_block',
	"e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("fd7222f3-ebb6-48d0-858a-0ad22a86e5aa",
	"61ed9659-8b4f-4a3d-bfc2-02e931a0536c",
	'act_el',
	"c73f7572-ce31-4792-9718-8a411cbfe1eb",
	0,
	'',
	"ee627ef3-1723-44c4-86f5-011942e8a178",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c73f7572-ce31-4792-9718-8a411cbfe1eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ElseIf Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("ed1020ba-6ea8-47c8-8327-8f03630cce4f",
	"61ed9659-8b4f-4a3d-bfc2-02e931a0536c",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"fd7222f3-ebb6-48d0-858a-0ad22a86e5aa",
	'');
INSERT INTO PE_PE
	VALUES ("61ed9659-8b4f-4a3d-bfc2-02e931a0536c",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cd83a65c-8aff-4835-bc6f-0a7c988adf47",
	"00000000-0000-0000-0000-000000000000",
	'transformVariable',
	'',
	'v_var = param.v_var;
smt = param.smt;

// create new variable
create object instance new_var of Variable;
relate new_var to smt across R457.''is declared by'';
new_var.name = v_var.Name;

// link in scope
select one scope related by smt->CodeBlock[R450.''is contained by''];
select any existing_var_in_scope related by scope->VariableInScope[R458] where ( selected.var_name == new_var.name );
if ( not_empty existing_var_in_scope )  // shadow variable of same name
  LOG::LogInfo( message:"warning: shadowing variable" );
  select one existing_var related by existing_var_in_scope->Variable[R458.''has in scope''];
  unrelate existing_var from scope across R458.''is in scope for'' using existing_var_in_scope;
end if;
create object instance var_in_scope of VariableInScope;
relate new_var to scope across R458.''is in scope for'' using var_in_scope;

// link data type
select one var_dt related by v_var->S_DT[R848];
select one var_obj related by v_var->V_INT[R814]->O_OBJ[R818];
if ( empty var_obj )
  select one var_obj related by v_var->V_INS[R814]->O_OBJ[R819];
end if;
var_dt = ::getInstRefTypeForClass( s_dt:var_dt, o_obj:var_obj );
select many s_dims related by v_var->S_DIM[R849];
var_type = TypeReference::getInstance( s_dt:var_dt, s_dims:s_dims );
relate var_type to new_var across R461.''defines declared type of'';',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9f592e3e-e19e-4b50-b018-fc17308c182c",
	"cd83a65c-8aff-4835-bc6f-0a7c988adf47",
	'v_var',
	"0e65b778-e815-4f26-b470-456b52561157",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0e65b778-e815-4f26-b470-456b52561157",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Variable>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("30b9e9b5-ce48-4643-b8de-1b3ed21cca43",
	"cd83a65c-8aff-4835-bc6f-0a7c988adf47",
	'smt',
	"056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	0,
	'',
	"9f592e3e-e19e-4b50-b018-fc17308c182c",
	'');
INSERT INTO PE_PE
	VALUES ("cd83a65c-8aff-4835-bc6f-0a7c988adf47",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fb475e46-f8de-40de-b96d-6bb83d18536b",
	"00000000-0000-0000-0000-000000000000",
	'transformStatements',
	'',
	'act_blk = param.act_blk;
block = param.block;
// transform all statements
// BridgePoint produces statement lists in reverse order of what they would be expected
// to be according to the role phrases: https://support.onefact.net/issues/5382.
// This code appears to select the last statement which is actually the first statement.
// Then, when iterating to the next statement, it iterates backwards which is actually
// forwards (gah).
select any act_smt from instances of ACT_SMT where false;
select many act_smts related by act_blk->ACT_SMT[R602];
for each smt in act_smts
  if ( empty act_smt )
    act_smt = smt;
  else
    if ( smt.LineNumber < act_smt.LineNumber or smt.LineNumber == act_smt.LineNumber and smt.StartPosition == act_smt.StartPosition )
      act_smt = smt;
    end if;
  end if;
end for;

select any prev_smt from instances of Statement where false;
smt_num = 1;
while ( not_empty act_smt )
  ::transformStatement( act_smt:act_smt, block:block, prev_smt:prev_smt );
  select any prev_smt related by block->Statement[R450.''is scope for''] where ( selected.statement_number == STR::itoa( i:smt_num + 1 ) ); // for OAL statements that result in 2 statements
  if ( not_empty prev_smt )
    smt_num = smt_num + 2;
  else
    select any prev_smt related by block->Statement[R450.''is scope for''] where ( selected.statement_number == STR::itoa( i:smt_num ) );
    smt_num = smt_num + 1;
  end if;
  select one act_smt related by act_smt->ACT_SMT[R661.''succeeds''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("a562eba2-df83-4436-a9ae-7627a446615b",
	"fb475e46-f8de-40de-b96d-6bb83d18536b",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("29d1e42f-caef-46df-8da1-5f6923cf541b",
	"fb475e46-f8de-40de-b96d-6bb83d18536b",
	'block',
	"e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	0,
	'',
	"a562eba2-df83-4436-a9ae-7627a446615b",
	'');
INSERT INTO PE_PE
	VALUES ("fb475e46-f8de-40de-b96d-6bb83d18536b",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59879fac-8e6b-40b0-a208-84d17e37f54c",
	"00000000-0000-0000-0000-000000000000",
	'transformBlockForFor',
	'',
	'upper_block = param.upper_block;
act_blk = param.act_blk;
iter_var = param.iter_var;
for_smt = param.for_smt;

// create code block
create object instance block of CodeBlock;
select one invocable related by upper_block->InvocableObject[R4000.''is invoked in''];
block.tab_depth = upper_block.tab_depth + 1;
relate block to invocable across R4000.''is invoked in'';
block.block_number = param.block_number;

// copy visibile variables from upper block
select many vars related by upper_block->Variable[R458.''has in scope''];
for each var in vars
  create object instance var_in_scope of VariableInScope;
  relate var to block across R458.''is in scope for'' using var_in_scope;
end for;

// transform all statements
::transformStatements( act_blk:act_blk, block:block );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("8515610e-01e9-493e-8d5f-d747c59134a5",
	"59879fac-8e6b-40b0-a208-84d17e37f54c",
	'upper_block',
	"e2eb4f67-ca2b-42ab-accf-5a2b475f8933",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("9a87e0d9-841a-4a09-b37b-25b4824326fa",
	"59879fac-8e6b-40b0-a208-84d17e37f54c",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"8515610e-01e9-493e-8d5f-d747c59134a5",
	'');
INSERT INTO S_SPARM
	VALUES ("c2e404d8-6149-4e1d-b8ac-d383aaee3d43",
	"59879fac-8e6b-40b0-a208-84d17e37f54c",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9a87e0d9-841a-4a09-b37b-25b4824326fa",
	'');
INSERT INTO S_SPARM
	VALUES ("4de857b8-5133-41f0-963d-e031c3ae7e57",
	"59879fac-8e6b-40b0-a208-84d17e37f54c",
	'iter_var',
	"896e75b4-b433-4661-b842-63b5ed57b2ae",
	0,
	'',
	"c2e404d8-6149-4e1d-b8ac-d383aaee3d43",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("896e75b4-b433-4661-b842-63b5ed57b2ae",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Variable>',
	'',
	'',
	'../architecture/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("e0e22dce-2ee2-4211-89d1-d69f7ffcbec4",
	"59879fac-8e6b-40b0-a208-84d17e37f54c",
	'for_smt',
	"092f9398-5f46-4c15-9a64-2d35cc9bb5e9",
	0,
	'',
	"4de857b8-5133-41f0-963d-e031c3ae7e57",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("092f9398-5f46-4c15-9a64-2d35cc9bb5e9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<For>',
	'',
	'',
	'../architecture/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("59879fac-8e6b-40b0-a208-84d17e37f54c",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3a7666da-ad54-4a28-b871-b4c9382cbb4d",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectionLink',
	'',
	'// TODO this does not consider direct links from one to other for linked associations

act_lnk = param.act_lnk;
smt = param.smt;
expr_number = param.expr_number;

// create expression
create object instance expr of Expression;
relate expr to smt across R775.''expressed within'';
expr.expression_number = expr_number;

// link type
select one o_obj related by act_lnk->O_OBJ[R678];
select any irdt related by o_obj->S_IRDT[R123] where ( ( selected.isSet and ::act_lnkGetMult( act_lnk:act_lnk ) == Mult::MANY ) or ( not selected.isSet and ::act_lnkGetMult( act_lnk:act_lnk ) == Mult::ONE ) );
select one s_dt related by irdt->S_DT[R17];
if ( empty s_dt )
  // TODO bad
end if;
select many s_dims from instances of S_DIM where false;
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to expr across R795.''defines type of'';

// create select expression
create object instance sel of SelectExpr;
relate sel to expr across R776;
create object instance sel_rel of SelectRelated;
relate sel_rel to sel across R789;

// transform the previous link
select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds''];
select any base_class from instances of Class where false;
if ( not_empty prev_lnk )
  ::transformSelectionLink( act_lnk:prev_lnk, expr_number:expr_number + ".1", smt:smt );
  select any prev_lnk_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr_number + ".1" );
  relate prev_lnk_expr to sel_rel across R791.''is basis for'';
  select one base_class related by prev_lnk->O_OBJ[R678]->Class[R409.''is basis for''];
else
  select one base_val related by act_lnk->ACT_SEL[R637]->V_VAL[R613];
  ::transformExpression( v_val:base_val, expr_number:expr_number + ".1", smt:smt );
  select any base_expr related by smt->Expression[R775.''may contain''] where ( selected.expression_number == expr_number + ".1" );
  relate base_expr to sel_rel across R791.''is basis for'';
  select one base_class related by base_val->V_IRF[R801]->V_VAR[R808]->V_INT[R814]->O_OBJ[R818]->Class[R409.''is basis for''];
  if ( empty base_class )
    select one base_class related by base_val->V_ISR[R801]->V_VAR[R809]->V_INS[R814]->O_OBJ[R819]->Class[R409.''is basis for''];
  end if;
end if;

// get the selector
select one r_rel related by act_lnk->R_REL[R681];
select one target_class related by o_obj->Class[R409.''is basis for''];
phrase = C_UTIL::stripTics( s:act_lnk.Rel_Phrase );
if ( "" == phrase ) // if the phrase is not included, may need to get the phrase for getting the selector
  select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                 selected.form_name == target_class.name and
                                                                 selected.part_name == base_class.name ); // if no phrase was included, the target and base class must be different
  if ( not_empty relationship )
    phrase = relationship.form_phrase;
  else
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == base_class.name and
                                                                   selected.part_name == target_class.name );
    if ( not_empty relationship )
      phrase = relationship.part_phrase;
    end if;
  end if;
end if;
selector_name = "R" + STR::itoa( i:r_rel.Numb ) + "_";
if ( "" != phrase )
  selector_name = selector_name + T::underscore( s:phrase ) + "_";
end if;
selector_name = selector_name + target_class.name;
select any selector related by base_class->InstanceSelector[R442.''selects instances through'']->Selector[R445] where ( selected.name == selector_name );
if ( empty selector )
  select any selector related by base_class->ClassSet[R406.''is type of single element in'']->SetSelector[R444.''selects instances through'']->Selector[R445] where ( selected.name == selector_name );
end if;
if ( not_empty selector )
  relate selector to sel_rel across R797.''invoked by'';
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("dc943ede-fbbb-439f-9b31-91af53e787ce",
	"3a7666da-ad54-4a28-b871-b4c9382cbb4d",
	'act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("74376552-7626-47f4-a819-3d944ba954bc",
	"3a7666da-ad54-4a28-b871-b4c9382cbb4d",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"dc943ede-fbbb-439f-9b31-91af53e787ce",
	'');
INSERT INTO S_SPARM
	VALUES ("5f872682-6a50-47f0-bd8e-0c8ae30b6e31",
	"3a7666da-ad54-4a28-b871-b4c9382cbb4d",
	'smt',
	"056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	0,
	'',
	"74376552-7626-47f4-a819-3d944ba954bc",
	'');
INSERT INTO PE_PE
	VALUES ("3a7666da-ad54-4a28-b871-b4c9382cbb4d",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("14b78b78-1e96-4ddc-b225-5609683f4072",
	"00000000-0000-0000-0000-000000000000",
	'transformPortMessage',
	'',
	'port = param.port;
msg = param.msg;

select any c_ep related by msg->Interface[R419.''defines message format for'']->C_I[R421.''is transformed from'']->C_EP[R4003] where ( selected.Name == msg.name );
select one c_po related by port->C_PO[R422.''is transformed from''];

// create port message
create object instance port_msg of PortMessage;
relate port to msg across R420 using port_msg;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = msg.name;
invocable.parent_name = port.name;
invocable.parent_package = port.package;
relate port_msg to invocable across R427;

// populate the OAL
invocable.oal = "";
select any act_act from instances of ACT_ACT where false;
select any spr_rep related by c_po->C_IR[R4016]->C_R[R4009]->SPR_REP[R4500] where ( selected.ExecutableProperty_Id == c_ep.Id );
select one spr_ro related by spr_rep->SPR_RO[R4502];
if ( not_empty spr_ro )
  invocable.oal = spr_ro.Action_Semantics_internal;
  select one act_act related by spr_ro->ACT_ROB[R685]->ACT_ACT[R698];
else
  select one spr_rs related by spr_rep->SPR_RS[R4502];
  if ( not_empty spr_rs )
    invocable.oal = spr_rs.Action_Semantics_internal;
    select one act_act related by spr_rs->ACT_RSB[R684]->ACT_ACT[R698];
  else
    select any spr_pep related by c_po->C_IR[R4016]->C_P[R4009]->SPR_PEP[R4501] where ( selected.ExecutableProperty_Id == c_ep.Id );
    select one spr_po related by spr_pep->SPR_PO[R4503];
    if ( not_empty spr_po )
      invocable.oal = spr_po.Action_Semantics_internal;
      select one act_act related by spr_po->ACT_POB[R687]->ACT_ACT[R698];
    else
      select one spr_ps related by spr_pep->SPR_PS[R4503];
      if ( not_empty spr_ps )
        invocable.oal = spr_ps.Action_Semantics_internal;
        select one act_act related by spr_ps->ACT_PSB[R686]->ACT_ACT[R698];
      end if;
    end if;
  end if;
end if;

// link type
type = TypeReference::getBuiltinTypeReference( name:"void" );
relate type to invocable across R428;

// create parameters
select any c_pp related by c_ep->C_PP[R4006];
prev_c_pp = c_pp;
// select first parameter
while ( not_empty prev_c_pp )
  c_pp = prev_c_pp;
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
end while;
while ( not_empty c_pp )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + c_pp.Name;
  parm.by_ref = ( 1 == c_pp.By_Ref );
  select one parm_dt related by c_pp->S_DT[R4007];
  select many s_dims related by c_pp->S_DIM[R4017];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
end while;

// add to import block
if ( port.provider and not msg.to_provider or not port.provider and msg.to_provider )
  select one file related by port->File[R401];
  ::addStringToImports( file:file, s:"io.ciera.cairn.interfaces.Message", type:ImportType::IMPL );
end if;

// relate the body
if ( not_empty act_act )
  relate act_act to invocable across R432.''actions transformed from'';
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("05f0167e-78b2-44e5-a8e6-5e1e211b14c8",
	"14b78b78-1e96-4ddc-b225-5609683f4072",
	'port',
	"fd525a31-5f7e-4b86-ab4f-d7ad8b09281d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fd525a31-5f7e-4b86-ab4f-d7ad8b09281d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../architecture/interface/interface.xtuml');
INSERT INTO S_SPARM
	VALUES ("ff9c2b40-e48a-4e3c-b344-c7afa715de9c",
	"14b78b78-1e96-4ddc-b225-5609683f4072",
	'msg',
	"ad08b5ef-5316-4ff4-a266-1fe49249c53f",
	0,
	'',
	"05f0167e-78b2-44e5-a8e6-5e1e211b14c8",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ad08b5ef-5316-4ff4-a266-1fe49249c53f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Message>',
	'',
	'',
	'../architecture/interface/interface.xtuml');
INSERT INTO PE_PE
	VALUES ("14b78b78-1e96-4ddc-b225-5609683f4072",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("04acdb19-1dbe-4c28-a736-ff73e44b1dbe",
	"00000000-0000-0000-0000-000000000000",
	'resolveAssociativeSelections',
	'',
	'// This function selects all ACT_LNK instances which select directly from one to
// other or other to one on an associative relationship and turns it into two 
// links.

select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  
  select one r_rel related by act_lnk->R_REL[R681];
  select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
  select one r_assr related by r_rel->R_ASSOC[R206]->R_ASSR[R211];
  select one assr_obj related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
  
  select one target_obj related by act_lnk->O_OBJ[R678];
  select any prev_lnk from instances of ACT_LNK where false;
  select any v_int from instances of V_INT where false;
  select any v_ins from instances of V_INS where false;
  select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds'']; // previous link
  select one base_obj related by prev_lnk->O_OBJ[R678];
  if ( empty base_obj )
    select one v_int related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_IRF[R801]->V_VAR[R808]->V_INT[R814]; // instance reference
    select one base_obj related by v_int->O_OBJ[R818];
    if ( empty base_obj )
      select one v_ins related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_ISR[R801]->V_VAR[R809]->V_INS[R814]; // instance reference set
      select one base_obj related by v_ins->O_OBJ[R819];
    end if;
  end if;
  
  // if this is an associative selection in which the link class is _not_ involved, it must be split up
  if ( not_empty r_assr and target_obj.Obj_ID != r_assr.Obj_ID and base_obj.Obj_ID != r_assr.Obj_ID )
  
    // create the first intermediate link
    create object instance act_lnk1 of ACT_LNK;
    act_lnk1.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk1.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk1.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk1.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk1.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk1.phraseColumn = act_lnk.phraseColumn;
    act_lnk1.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    relate r_rel to act_lnk1 across R681;
    relate act_lnk1 to assr_obj across R678;
    if ( 1 == r_assr.Mult or ( not_empty prev_lnk and Multiplicity::Many == prev_lnk.Mult ) or not_empty v_ins )
      act_lnk1.Mult = Multiplicity::Many; // always many if the associative object has multiplicity many, or the starting point is multiplicity many
    else
      if ( target_obj.Obj_ID != base_obj.Obj_ID and r_aoth.Obj_ID == target_obj.Obj_ID ) or 
         ( target_obj.Obj_ID == base_obj.Obj_ID and r_aoth.Txt_Phrs == C_UTIL::stripTics( s:act_lnk.Rel_Phrase ) )  // one to other
        if ( 1 == r_aoth.Mult )
          act_lnk1.Mult = Multiplicity::Many;
        else
          act_lnk1.Mult = Multiplicity::One;
        end if;
      else // other to one
        if ( 1 == r_aone.Mult )
          act_lnk1.Mult = Multiplicity::Many;
        else
          act_lnk1.Mult = Multiplicity::One;
        end if;
      end if;
    end if;

    // create the second intermediate link
    create object instance act_lnk2 of ACT_LNK;
    act_lnk2.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk2.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk2.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk2.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk2.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk2.phraseColumn = act_lnk.phraseColumn;
    act_lnk2.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    act_lnk2.Mult = act_lnk.Mult; // the second link always gets the same multiplicity as the original link
    relate r_rel to act_lnk2 across R681;
    relate act_lnk2 to target_obj across R678;
    
    // link the two together and insert into the order
    relate act_lnk1 to act_lnk2 across R604.''precedes'';
    select one next_lnk related by act_lnk->ACT_LNK[R604.''precedes''];
    if ( not_empty next_lnk )
      unrelate act_lnk from next_lnk across R604.''precedes'';
      relate act_lnk2 to next_lnk across R604.''precedes'';
    end if;
    if ( not_empty prev_lnk )
      unrelate act_lnk from prev_lnk across R604.''succeeds'';
      relate act_lnk1 to prev_lnk across R604.''succeeds'';
    else // this is the starting point
      select one act_sel related by act_lnk->ACT_SEL[R637];
      unrelate act_lnk from act_sel across R637;
      relate act_lnk1 to act_sel across R637;
    end if;
    
    // dispose old link
    unrelate target_obj from act_lnk across R678;
    unrelate r_rel from act_lnk across R681;
    delete object instance act_lnk;
    
  end if;
  
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("04acdb19-1dbe-4c28-a736-ff73e44b1dbe",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6ea429a3-849e-4560-8daa-d650e2021aae",
	"00000000-0000-0000-0000-000000000000",
	'getCompDefForStatement',
	'',
	'smt = param.smt;
select one invocable related by smt->CodeBlock[R450.''is contained by'']->InvocableObject[R4000.''is invoked in''];
select one comp_def related by invocable->Function[R427]->ComponentDefinition[R405.''can execute synchronously within''];
if ( empty comp_def )
  select one comp_def related by invocable->PortMessage[R427]->Port[R420.''is implemented within'']->ComponentDefinition[R417.''passes messages for''];
  if ( empty comp_def )
    select one comp_def related by invocable->Operation[R427]->Class[R416.''provided by'']->ComponentDefinition[R408.''forms instance population of''];
    if ( empty comp_def )
      select one comp_def related by invocable->AttributeDerivation[R427]->AttributeAccessor[R441.''calculates value for'']->Attribute[R4510.''gets and sets'']->Class[R410.''abstracts data for'']->ComponentDefinition[R408.''forms instance population of''];
      // TODO utility will return empty
    end if;
  end if;
end if;
return comp_def;',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("2402572a-83c5-4285-ace8-b01b9bb21688",
	"6ea429a3-849e-4560-8daa-d650e2021aae",
	'smt',
	"056a9b55-7c4c-45a4-a684-ea45fce8fa86",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("6ea429a3-849e-4560-8daa-d650e2021aae",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b12433f2-8d27-497d-90cb-994dc5f0525e",
	"00000000-0000-0000-0000-000000000000",
	'is_primitive_type',
	'',
	'type = param.type;
select one builtin related by type->BuiltInType[R407];
if ( not_empty builtin )
  return builtin.primitive;
else
  return false;
end if;',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("c824ddfb-29d7-4e3b-ba45-2435ef02c589",
	"b12433f2-8d27-497d-90cb-994dc5f0525e",
	'type',
	"be784cfe-3f8b-4e25-b183-484885b71173",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("be784cfe-3f8b-4e25-b183-484885b71173",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Type>',
	'',
	'',
	'../architecture/type/type.xtuml');
INSERT INTO PE_PE
	VALUES ("b12433f2-8d27-497d-90cb-994dc5f0525e",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c0d8df16-ca3e-4dfe-afd3-3b67c4953da0",
	"00000000-0000-0000-0000-000000000000",
	'linkParameter',
	'',
	'invocable = param.invocable;
parm = param.parameter;
// link parameter
select any last_parm related by invocable->FormalParameter[R429];
select one next_parm related by last_parm->FormalParameter[R404.''precedes''];
while ( not_empty next_parm )
  last_parm = next_parm;
  select one next_parm related by last_parm->FormalParameter[R404.''precedes''];
end while;
if ( not_empty last_parm )
  relate parm to last_parm across R404.''follows'';
end if;
relate parm to invocable across R429;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("0ace3d4c-3db1-4306-af9e-603a1d4f8ad7",
	"c0d8df16-ca3e-4dfe-afd3-3b67c4953da0",
	'invocable',
	"30c7a5ba-c6d9-44fd-8e61-f22cde8fdc41",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a432e006-434b-4b8d-9b6c-e3e3e240deb5",
	"c0d8df16-ca3e-4dfe-afd3-3b67c4953da0",
	'parameter',
	"a4048d05-d8f6-4f96-b1fc-79a73158a744",
	0,
	'',
	"0ace3d4c-3db1-4306-af9e-603a1d4f8ad7",
	'');
INSERT INTO PE_PE
	VALUES ("c0d8df16-ca3e-4dfe-afd3-3b67c4953da0",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("64ba7d8b-4444-49d3-87cb-8e5c63278248",
	"00000000-0000-0000-0000-000000000000",
	'transformUserDefinedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = "";
type.resolve( s_dt:s_dt );
create object instance udt of UserDefinedType;
relate type to udt across R407;
relate udt to file across R401;

// add import
::addStringToImports( file:file, s:"io.ciera.summit.types.IXtumlType", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("38e5b048-c9f5-427f-8dd4-78c692c104f2",
	"64ba7d8b-4444-49d3-87cb-8e5c63278248",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("64ba7d8b-4444-49d3-87cb-8e5c63278248",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6fab7686-b52d-4e9a-926a-9ee2876b2884",
	"00000000-0000-0000-0000-000000000000",
	'resolveUserDefinedTypes',
	'',
	'select many udts from instances of UserDefinedType;
for each udt in udts

  select one type related by udt->Type[R407];
  select one base_type related by type->S_DT[R423]->S_UDT[R17]->S_DT[R18]->Type[R423];
  if ( empty base_type )
    // TODO bad
  end if;
  
  type.default_value = base_type.default_value;
  relate udt to base_type across R3802;
  
  // add to imports
  select one file related by udt->File[R401];
  ::addTypeToImports( file:file, type_to_import:base_type, type:ImportType::IMPL );

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("6fab7686-b52d-4e9a-926a-9ee2876b2884",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("06787f13-1c16-4275-879c-00bbeee7cb88",
	1,
	"acef9848-aa6d-428b-9882-cc90deb0a54a",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("acef9848-aa6d-428b-9882-cc90deb0a54a",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'ciera',
	'',
	0,
	'../ciera.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'ciera',
	1,
	'../../ciera.xtuml');
