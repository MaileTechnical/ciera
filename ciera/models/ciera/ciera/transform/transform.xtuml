-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'transform',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("a442477a-0195-4034-8986-e4129bb601d0",
	112,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'4.1.17',
	'ciera::ciera::transform');
INSERT INTO DIM_DIA
	VALUES ("a442477a-0195-4034-8986-e4129bb601d0",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	"00000000-0000-0000-0000-000000000000",
	'transformApplication',
	'',
	'root_package = param.root_package;
select one s_sys related by root_package->S_SYS[R1405];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_sys.Name, start_lower:false ) + "Application";
file.path = T::l( s:T::r( s:s_sys.Name ) );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the application object
create object instance app of Application;
relate app to file across R401;

// create application executors
index = 0;
while ( index < 1 ) // single executor for now
  create object instance executor of ApplicationExecutor;
  executor.index = index;
  relate executor to app across R4027.''executes tasks for'';
  index = index + 1;
end while;

// create the import block
::addStringToImports( file:file, s:"io.ciera.cairn.application.ApplicationExecutor" );
::addStringToImports( file:file, s:"io.ciera.cairn.application.tasks.GenericExecutionTask" );
::addStringToImports( file:file, s:"io.ciera.summit.application.IApplication" );      
::addStringToImports( file:file, s:"io.ciera.summit.application.IRunContext" );       
::addStringToImports( file:file, s:"io.ciera.summit.components.IComponent" );         
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException" );

// translate components definitions
select many c_cs related by root_package->PE_PE[R8000]->C_C[R8001];
select many cl_ics related by root_package->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
c_cs = c_cs | cl_ics;
select any empty_comp_def from instances of ComponentDefinition where false;
select any current_comp_inst from instances of ComponentInstantiation where false;
for each c_c in c_cs
  select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  if ( empty comp_def )
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def );
    select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  end if;
  create object instance comp_inst of ComponentInstantiation;
  relate  comp_def to app across R426 using comp_inst;
  select one comp_def_file related by comp_def->File[R401];
  ::addFileToImports( file:file, file_to_import:comp_def_file );
  select any executor from instances of ApplicationExecutor where ( selected.index == 0 );  // single executor for now
  relate executor to comp_inst across R4028.''provides execution context for'';
  if ( not_empty current_comp_inst )
    relate comp_inst to current_comp_inst across R4029.''follows'';
  end if;
  current_comp_inst = comp_inst;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("6b6c262c-3690-4123-b000-38fb9cc04e80",
	"86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	'root_package',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO PE_PE
	VALUES ("86c4c157-03cd-481b-a5ed-c7c91b1ad36e",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	"00000000-0000-0000-0000-000000000000",
	'transformComponentDefinition',
	'',
	'c_c = param.c_c;
containing_comp_def = param.containing_comp_def;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:c_c.Name, start_lower:false );
if ( not_empty ep_pkg )
  file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
else
  file.path = containing_comp_def.package + T::l( s:T::r( s:containing_comp_def.name ) );
end if;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the component definition object
create object instance comp_def of ComponentDefinition;
relate comp_def to file across R401;
comp_def.extends = "Component";

// create universal creator, relator, unrelator
create object instance universal_creator of UniversalCreator;
relate universal_creator to comp_def across R4564.''adds instances to population of'';
create object instance universal_relator of UniversalRelator;
relate universal_relator to comp_def across R4565.''instances linked in population of'';
create object instance universal_unrelator of UniversalUnrealtor;
relate universal_unrelator to comp_def across R4566.''instances unlinked in population of'';

// transform ports
select many c_pos related by c_c->C_PO[R4010];
for each c_po in c_pos
  ::transformPort( c_po:c_po, comp_def:comp_def );
end for;

// transform inner packages
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
for each ep_pkg in ep_pkgs
  ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def );
end for;

// transform inner components
select many inner_c_cs related by c_c->PE_PE[R8003]->C_C[R8001];
for each inner_c_c in inner_c_cs
  ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def );
end for;

// transform instance population selectors
select many objs related by comp_def->ClassInComponent[R408]->Class[R408.''maintains instances of''];
if ( cardinality objs > 0 )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IWhere" );
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IInstanceSet" );
end if;
for each obj in objs
  // create ''any'' selector
  create object instance any_inst_pop_selector of InstancePopulationSelector;
  any_inst_pop_selector.name = "selectAnyFromInstances_" + obj.name;
  any_inst_pop_selector.class_key_letters = obj.key_letters;
  any_inst_pop_selector.returns_set = false;
  relate any_inst_pop_selector to comp_def across R447.''selects instances out of population of'';
  // link type
  select any s_irdt1 related by obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
  select one s_dt1 related by s_irdt1->S_DT[R17];
  if ( empty s_dt1 )
    // TODO bad
  end if;
  type1 = UnresolvedType::getInstance( s_dt:s_dt1 );
  relate type1 to any_inst_pop_selector across R449.''shapes return of'';
  // create ''many'' selector
  create object instance many_inst_pop_selector of InstancePopulationSelector;
  many_inst_pop_selector.name = "selectManyFromInstances_" + obj.name;
  many_inst_pop_selector.class_key_letters = obj.key_letters;
  many_inst_pop_selector.returns_set = true;
  relate many_inst_pop_selector to comp_def across R447.''selects instances out of population of'';
  // link type
  select any s_irdt2 related by obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
  select one s_dt2 related by s_irdt2->S_DT[R17];
  if ( empty s_dt2 )
    // TODO bad
  end if;
  type2 = UnresolvedType::getInstance( s_dt:s_dt2 );
  relate type2 to many_inst_pop_selector across R449.''shapes return of'';
end for;

// create import block
::addStringToImports( file:file, s:"io.ciera.cairn.components.Component" );
::addStringToImports( file:file, s:"io.ciera.summit.application.IRunContext" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IModelInstance" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.InstancePopulationException" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException" );
::addStringToImports( file:file, s:"java.util.Map" );
::addStringToImports( file:file, s:"java.util.HashMap" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9e250ca1-996f-471c-9f10-bb5ad2591f03",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("35145c47-5490-4738-a0b2-7e513f9ed71c",
	"a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"9e250ca1-996f-471c-9f10-bb5ad2591f03",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO PE_PE
	VALUES ("a77051bc-22a5-45fc-a0ba-6e4ceeaa7802",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c26da85-1e78-4183-88ca-60811dc084db",
	"00000000-0000-0000-0000-000000000000",
	'transformPackage',
	'',
	'ep_pkg = param.ep_pkg;
containing_comp_def = param.containing_comp_def;
select many pe_pes related by ep_pkg->PE_PE[R8000];

// transform functions
select many s_syncs related by pe_pes->S_SYNC[R8001];
for each s_sync in s_syncs
  ::transformFunction( s_sync:s_sync, comp_def:containing_comp_def );
end for;

// transform constants

// transform interfaces
select many c_is related by pe_pes->C_I[R8001];
for each c_i in c_is
  ::transformInterface( c_i:c_i );
end for;

// transform datatypes
select many edts related by pe_pes->S_DT[R8001]->S_EDT[R17]->S_DT[R17];
for each edt in edts
  ::transformEnumeratedType( s_dt:edt );
end for;

// transform EEs
select many s_ees related by pe_pes->S_EE[R8001];
for each s_ee in s_ees
  ::transformUtility( s_ee:s_ee, ep_pkg:ep_pkg, containing_comp_def:containing_comp_def, exclude:false );
end for;

// transform classes
select many o_objs related by pe_pes->O_OBJ[R8001];
for each o_obj in o_objs
  ::transformClass( o_obj:o_obj, containing_comp_def:containing_comp_def );
end for;

// transform imported classes (must be done before associations are transformed)
select many o_iobjs related by pe_pes->O_IOBJ[R8001];
for each o_iobj in o_iobjs
  select one o_obj related by o_iobj->O_OBJ[R101];
  ::transformClass( o_obj:o_obj, containing_comp_def:containing_comp_def );
end for;

// transform associations
select many r_rels related by pe_pes->R_REL[R8001];
for each r_rel in r_rels
  ::transformAssociation( r_rel:r_rel, containing_comp_def:containing_comp_def );
end for;

// transform selectors
select many objs related by o_objs->Class[R409.''is basis for''];
for each obj in objs
  ::transformSelectors( obj:obj );
end for;

// transform attribute references
for each obj in objs
  ::transformAttributeReferences( obj:obj );
end for;

// transform relators/unrelators
for each r_rel in r_rels
  select any rel from instances of Relationship where ( selected.num == r_rel.Numb );
  if ( not_empty rel )
    ::transformInstanceLinkModifiers( rel:rel, containing_comp_def:containing_comp_def );
  else
    // TODO bad
  end if;
end for;

// transform components
select many c_cs related by pe_pes->C_C[R8001];
for each c_c in c_cs
  ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def );
end for;

// transform packages
select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
for each inner_ep_pkg in inner_ep_pkgs
  ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e05335a1-ada2-43dd-bdb1-f29837aff1fc",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0ca0ea7b-7e27-4164-8c8f-51956eba948a",
	"1c26da85-1e78-4183-88ca-60811dc084db",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"e05335a1-ada2-43dd-bdb1-f29837aff1fc",
	'');
INSERT INTO PE_PE
	VALUES ("1c26da85-1e78-4183-88ca-60811dc084db",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4372e9ec-b226-4bdc-9219-9427ca71b423",
	"00000000-0000-0000-0000-000000000000",
	'transformFunction',
	'',
	's_sync = param.s_sync;
comp_def = param.comp_def;

// create function object
create object instance func of Function;
relate func to comp_def across R405;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_sync.Name;
invocable.parent_name = comp_def.name;
invocable.parent_package = comp_def.package;
relate func to invocable across R427;

// link type
select one s_dt related by s_sync->S_DT[R25];
type = UnresolvedType::getInstance( s_dt:s_dt );
relate type to invocable across R428;

// create parameters
select any s_sparm related by s_sync->S_SPARM[R24];
prev_s_sparm = s_sparm;
// select first parameter
while ( not_empty prev_s_sparm )
  s_sparm = prev_s_sparm;
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
end while;
while ( not_empty s_sparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = s_sparm.Name;
  parm.by_ref = ( 1 == s_sparm.By_Ref );
  select one parm_dt related by s_sparm->S_DT[R26];
  parm_type = UnresolvedType::getInstance( s_dt:parm_dt );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
end while;

// see if this is an initializer function
select any init_function_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                             selected.path == ::packageToMarkingPath( package:comp_def.package ) + "::" + comp_def.name and
                                                             selected.feature_name == "InitFunction" );
if ( not_empty init_function_mark and func.name == init_function_mark.value )
  select any s_sparm related by s_sync->S_SPARM[R24];
  if ( empty s_sparm )
    select one init_function related by comp_def->Function[R4561.''initialized by''];
    if ( empty init_function )
      relate func to comp_def across R4561.''initializes'';
    else
      // TODO bad
    end if;
  else
    // TODO bad
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("20dcc580-c900-4c37-9db9-c96b57ce0c7a",
	"4372e9ec-b226-4bdc-9219-9427ca71b423",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("30cff3bd-5277-4221-8d57-b94d725a461b",
	"4372e9ec-b226-4bdc-9219-9427ca71b423",
	'comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"20dcc580-c900-4c37-9db9-c96b57ce0c7a",
	'');
INSERT INTO PE_PE
	VALUES ("4372e9ec-b226-4bdc-9219-9427ca71b423",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("26bcd5a8-82fd-48ba-8dfc-40a65ebfd881",
	"00000000-0000-0000-0000-000000000000",
	'transformBuiltinTypes',
	'',
	'select many s_dts from instances of S_DT;
for each s_dt in s_dts

  if ( ::s_dtIsBuiltin( s_dt:s_dt ) )

    type_name = "";
    type_package = "";
    type_primitive = false;
    type_unique = false;
    type_inst = false;
    type_instset = false;
    type_default_value = "";
    if ( "boolean" == s_dt.Name )
      type_name = "boolean";
      type_primitive = true;
      type_default_value = "false";
    elif ( "component_ref" == s_dt.Name )
      type_name = "IComponent";
      type_package = "io.ciera.summit.components";
      type_default_value = "null";
    elif ( "date" == s_dt.Name )
      type_name = "Date";
      type_package = "io.ciera.summit.time";
      type_default_value = "null";
    elif ( "inst<Event>" == s_dt.Name )
      type_name = "Event";
      type_package = "io.ciera.summit.statemachine";
      type_default_value = "null";
    elif ( "inst_ref<Timer>" == s_dt.Name )
      type_name = "Timer";
      type_package = "io.ciera.summit.time";
      type_default_value = "null";
    elif ( "integer" == s_dt.Name )
      type_name = "int";
      type_primitive = true;
      type_default_value = "0";
    elif ( "real" == s_dt.Name )
      type_name = "float";
      type_primitive = true;
      type_default_value = "0f";
    elif ( "string" == s_dt.Name )
      type_name = "String";
      type_default_value = STR::quote() + STR::quote();
    elif ( "timestamp" == s_dt.Name )
      type_name = "TimeStamp";
      type_package = "io.ciera.summit.time";
      type_default_value = "null";
    elif ( "unique_id" == s_dt.Name )
      type_name = "UniqueId";
      type_package = "io.ciera.summit.classes";
      type_unique = true;
      type_default_value = "new UniqueId()";
    elif ( "void" == s_dt.Name )
      type_name = "void";
      type_primitive = true;
      type_default_value = "";
    elif ( "inst_ref_set<Object>" == s_dt.Name )
      type_name = "IInstanceSet";
      type_package = "io.ciera.summit.classes";
      type_instset = true;
      type_default_value = "null";
    elif ( "inst_ref<Object>" == s_dt.Name )
      type_name = "IModelInstance";
      type_package = "io.ciera.summit.classes";
      type_inst = true;
      type_default_value = "null";
    end if;

    if ( "" != type_name )
      create object instance type of Type;
      type.name = type_name;
      type.package = type_package;
      type.default_value = type_default_value;
      relate type to s_dt across R423;
      create object instance builtin of BuiltInType;
      relate builtin to type across R407;
      builtin.primitive = type_primitive;
      builtin.unique = type_unique;
      builtin.inst = type_inst;
      builtin.instset = type_instset;
    end if;
  
  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("26bcd5a8-82fd-48ba-8dfc-40a65ebfd881",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	"00000000-0000-0000-0000-000000000000",
	'transformClass',
	'',
	'o_obj = param.o_obj;
containing_comp_def = param.containing_comp_def;
select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];

// create the object file
create object instance file of File;
file.name = ::camelCaseName( name:o_obj.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the object
create object instance obj of Class;
obj.key_letters = o_obj.Key_Lett;
obj.extends = "ModelInstance";
relate obj to file across R401;

// add the class to the component
create object instance cic of ClassInComponent;
relate obj to containing_comp_def across R408 using cic;
create object instance instance_creator of InstanceCreator;
instance_creator.name = "createObjectInstanceOf" + obj.name;
relate instance_creator to containing_comp_def across R4550.''adds instances to population of'';
relate instance_creator to cic across R4551.''creates instances of'';

// create the instance type
create object instance type of Type;
type.name = obj.name;
type.package = obj.package;
select any s_irdt related by o_obj->S_IRDT[R123] where ( not selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( not_empty s_dt )
  relate s_dt to type across R423.''is basis of'';
else
  // TODO bad
end if;
type.default_value = "EMPTY_" + T::u( s:T::underscore( s:obj.name ) );
relate type to obj across R407;

// relate to the OOA class
relate obj to o_obj across R409;

// transform attributes
select many o_attrs related by o_obj->O_ATTR[R102];
for each o_attr in o_attrs
  if ( "current_state" != o_attr.Name )
    ::transformAttribute( o_attr:o_attr, obj:obj );
  end if;
end for;

// transform operations
select many o_tfrs related by o_obj->O_TFR[R115];
for each o_tfr in o_tfrs
  ::transformOperation( o_tfr:o_tfr, obj:obj );
end for;

// transform the set object
::transformClassSet( obj:obj, ep_pkg:ep_pkg );

// add to the containing component imports
select one component_file related by containing_comp_def->File[R401];
::addFileToImports( file:component_file, file_to_import:file );
select one set_file related by obj->ClassSet[R406.''is type of single element in'']->File[R401];
::addFileToImports( file:component_file, file_to_import:set_file );
::addStringToImports( file: component_file, s:"io.ciera.summit.exceptions.XtumlException" );
::addStringToImports( file: component_file, s:"io.ciera.summit.exceptions.InstancePopulationException" );

// create the import block
::addStringToImports( file:file, s:"io.ciera.summit.classes.IEmptyInstance" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IInstanceSet" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IInstancePopulation" );
::addStringToImports( file:file, s:"io.ciera.cairn.classes.ModelInstance" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("aa6be7c4-dd4e-4044-bbf1-81678db4c1f5",
	"5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("9e76c7fd-92f6-44e6-92b5-aa4874148abc",
	"5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"aa6be7c4-dd4e-4044-bbf1-81678db4c1f5",
	'');
INSERT INTO PE_PE
	VALUES ("5d5d0e20-88ef-45c3-9564-38aff4db30b8",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a14540ae-c3dd-4248-890f-99953be47efa",
	"00000000-0000-0000-0000-000000000000",
	'transformClassSet',
	'',
	'obj = param.obj;
ep_pkg = param.ep_pkg;

// create the class set object
create object instance objset of ClassSet;
relate objset to obj across R406;
objset.extends = "InstanceSet";

// create the object file
create object instance file of File;
file.name = obj.name + "Set";
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

relate objset to file across R401;

// create the instance type
create object instance type of Type;
type.name = objset.name;
type.package = objset.package;
select any s_irdt related by obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( not_empty s_dt )
  relate s_dt to type across R423.''is basis of'';
else
  // TODO bad
end if;
type.default_value = "("  + objset.name + ")(new " + objset.name + "()).toImmutableSet()";
relate type to objset across R407;

// create the import block
::addStringToImports( file:file, s:"io.ciera.summit.classes.IWhere" );
::addStringToImports( file:file, s:"io.ciera.cairn.classes.InstanceSet" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("ceb8a015-73b2-4bc0-acbc-a5fa93f21e67",
	"a14540ae-c3dd-4248-890f-99953be47efa",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ac93823e-2644-440b-977c-1f4e8480ec59",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class>',
	'',
	'',
	'../architecture/class/class.xtuml');
INSERT INTO S_SPARM
	VALUES ("72a8d944-1499-487e-9f40-06dbfc501f96",
	"a14540ae-c3dd-4248-890f-99953be47efa",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"ceb8a015-73b2-4bc0-acbc-a5fa93f21e67",
	'');
INSERT INTO PE_PE
	VALUES ("a14540ae-c3dd-4248-890f-99953be47efa",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ba8e6cdd-5bb7-4a8b-9ff5-8f0d96755d95",
	"00000000-0000-0000-0000-000000000000",
	'resolveTypes',
	'',
	'select many unresolved_types from instances of UnresolvedType;
for each unresolved_type in unresolved_types
  select one type related by unresolved_type->Type[R407];
  select one s_dt related by type->S_DT[R423];

  select any new_type from instances of Type where false;

  // resolve builtin types
  if ( ::s_dtIsBuiltin( s_dt:s_dt ) )
    select many builtin_types from instances of BuiltInType;
    select any new_type related by builtin_types->Type[R407] where ( selected.DT_ID == s_dt.DT_ID );
  else
  
  // resolve class reference types
  select one s_irdt related by s_dt->S_IRDT[R17];
  if ( not_empty s_irdt )
    select one o_obj related by s_irdt->O_OBJ[R123];
    if ( s_irdt.isSet )
      // class sets
      select one new_type related by o_obj->Class[R409]->ClassSet[R406]->Type[R407];
    else
      // classes
      select one new_type related by o_obj->Class[R409]->Type[R407];
    end if;
  else

  // resolve enumerated types
  select one s_edt related by s_dt->S_EDT[R17];
  if ( not_empty s_edt )
    select many enum_types from instances of EnumeratedType;
    select any new_type related by enum_types->Type[R407] where ( selected.DT_ID == s_dt.DT_ID );
  end if;
  end if;
  end if;
  
  // unrelate old types and hook up the new types
  if ( not_empty new_type )
    select one old_type related by unresolved_type->Type[R407];
    select many attrs related by old_type->Attribute[R424];
    for each attr in attrs
      unrelate old_type from attr across R424;
      relate new_type to attr across R424;
    end for;
    select many invocables related by old_type->InvocableObject[R428];
    for each invocable in invocables
      unrelate old_type from invocable across R428;
      relate new_type to invocable across R428;
    end for;
    select many parms related by old_type->FormalParameter[R431];
    for each parm in parms
      unrelate old_type from parm across R431;
      relate new_type to parm across R431;
    end for;
    select many selectors related by old_type->Selector[R446.''shapes return of''];
    for each selector in selectors
      unrelate old_type from selector across R446.''shapes return of'';
      relate new_type to selector across R446.''shapes return of'';
    end for;
    select many instpopselectors related by old_type->InstancePopulationSelector[R449.''shapes return of''];
    for each instpopselector in instpopselectors
      unrelate old_type from instpopselector across R449.''shapes return of'';
      relate new_type to instpopselector across R449.''shapes return of'';
    end for;
    old_type.dispose();
  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("ba8e6cdd-5bb7-4a8b-9ff5-8f0d96755d95",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("19215085-ca84-43cb-bb81-6ffd50262136",
	"00000000-0000-0000-0000-000000000000",
	'transformAttribute',
	'',
	'o_attr = param.o_attr;
obj = param.obj;

// create the attribute
create object instance attr of Attribute;
select one rattr related by o_attr->O_RATTR[R106];
if ( not_empty rattr )
  attr.name = "ref_" + o_attr.Name;
else
  attr.name = "m_" + o_attr.Name;
end if;
attr.base_name = o_attr.Name;
relate attr to obj across R410;

// set the type
select one s_dt related by o_attr->S_DT[R114];
if ( "same_as<Base_Attribute>" == s_dt.Name )
  select one s_dt related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
end if;
if ( empty s_dt )
  // TODO bad
end if;
type = UnresolvedType::getInstance( s_dt:s_dt );
relate type to attr across R424;

// link OOA attribute
relate o_attr to attr across R414;

// create accessors
create object instance getter of AttributeAccessor;
getter.accessor_type = AttributeAccessor::GETTER;
relate getter to attr across R4510.''gets and sets'';
create object instance setter of AttributeAccessor;
setter.accessor_type = AttributeAccessor::SETTER;
relate setter to attr across R4510.''gets and sets'';

// add import to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.EmptyInstanceException" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("7b1297b8-b278-4ae8-a571-70b7bf262f38",
	"19215085-ca84-43cb-bb81-6ffd50262136",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("7a7146b3-82c0-458a-bf9d-b99938b7d7c7",
	"19215085-ca84-43cb-bb81-6ffd50262136",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"7b1297b8-b278-4ae8-a571-70b7bf262f38",
	'');
INSERT INTO PE_PE
	VALUES ("19215085-ca84-43cb-bb81-6ffd50262136",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a566ca37-5a57-4f7f-9212-c9cf475d697d",
	"00000000-0000-0000-0000-000000000000",
	'transformInstanceReferenceTypes',
	'',
	'// make sure an instance reference type is created for every class
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  select one packageableElem related by o_obj->PE_PE[R8001];
  select one package related by packageableElem->EP_PKG[R8000];
  select one component related by packageableElem->C_C[R8003];

  // Make sure the IRDTs don''t already exist before creating new ones.  Check
  // the single and set version and create whatever does not exist.
  select any existing_irdt related by o_obj->S_IRDT[R123] where selected.isSet == false;
  if (empty existing_irdt) 
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt of S_DT;
    relate pe to dt across R8001;
    create object instance irdt of S_IRDT;
    irdt.isSet = false;
    relate dt to irdt across R17;
    dt.Name = "inst_ref<" + o_obj.Name + ">" ;
    relate o_obj to irdt across R123;
  end if;

  select any existing_irdt_set related by o_obj->S_IRDT[R123] where selected.isSet == true;
  if (empty existing_irdt_set) 
    create object instance pe of PE_PE;
    relate pe to package across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt2 of S_DT;
    relate pe to dt2 across R8001;
    create object instance irsdt of S_IRDT;
    irsdt.isSet = true;
    relate irsdt to dt2 across R17;
    dt2.Name = "inst_ref_set<" + o_obj.Name + ">" ;
    relate o_obj to irsdt across R123;
  end if;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("a566ca37-5a57-4f7f-9212-c9cf475d697d",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("eb2d19db-99fd-443a-891e-1510a4224c8a",
	"00000000-0000-0000-0000-000000000000",
	'transformEnumeratedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = type.name + ".UNINITIALIZED_ENUM";
relate type to s_dt across R423;
create object instance edt of EnumeratedType;
relate type to edt across R407;
relate edt to file across R401;

// transform enumerators
select many enums related by s_dt->S_EDT[R17]->S_ENUM[R27];
value = 0;
for each enumer in enums
  create object instance e of Enumerator;
  e.name = T::u( s:enumer.Name );
  e.value = value;
  value = value + 1;
  relate e to edt across R415;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("39ff61e1-b925-497a-8d8a-1ea86381dec4",
	"eb2d19db-99fd-443a-891e-1510a4224c8a",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("eb2d19db-99fd-443a-891e-1510a4224c8a",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("056fd761-beb4-4eed-85d2-b466883d17cb",
	"00000000-0000-0000-0000-000000000000",
	'resolveTypeImports',
	'',
	'select many types from instances of Type;
for each type in types
  select many files related by type->Attribute[R424]->Class[R410]->File[R401];
  select many more_files related by type->FormalParameter[R431]->InvocableObject[R429]->Function[R427]->ComponentDefinition[R405.''can execute synchronously within'']->File[R401];
  files = files | more_files;
  select many more_files related by type->FormalParameter[R431]->InvocableObject[R429]->Operation[R427]->Class[R416]->File[R401];
  files = files | more_files;
  select many more_files related by type->FormalParameter[R431]->InvocableObject[R429]->Message[R427]->Interface[R419]->File[R401];
  files = files | more_files;
  select many more_files related by type->FormalParameter[R431]->InvocableObject[R429]->Message[R427]->Port[R420]->File[R401];
  files = files | more_files;
  select many more_files related by type->FormalParameter[R431]->InvocableObject[R429.''shapes data for'']->UtilityFunction[R427]->Utility[R4559.''provided by'']->File[R401];
  files = files | more_files;
  select many more_files related by type->InvocableObject[R428]->Operation[R427]->Class[R416]->File[R401];
  files = files | more_files;
  select many more_files related by type->InvocableObject[R428]->Message[R427]->Interface[R419]->File[R401];
  files = files | more_files;
  select many more_files related by type->InvocableObject[R428]->Message[R427]->Port[R420]->File[R401];
  files = files | more_files;
  select many more_files related by type->InvocableObject[R428.''defines return type for'']->UtilityFunction[R427]->Utility[R4559.''provided by'']->File[R401];
  files = files | more_files;
  select many more_files related by type->Selector[R446.''shapes return of'']->InstanceSelector[R445]->Class[R442.''navigates from'']->File[R401];
  files = files | more_files;
  select many more_files related by type->Selector[R446.''shapes return of'']->SetSelector[R445]->ClassSet[R444.''navigates from'']->File[R401];
  files = files | more_files;
  select many more_files related by type->InstancePopulationSelector[R449.''shapes return of'']->ComponentDefinition[R447.''selects instances out of population of'']->File[R401];
  files = files | more_files;
  for each file in files
    type.addToImports( file:file );
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("056fd761-beb4-4eed-85d2-b466883d17cb",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("03e1ea6e-74af-412c-b034-76ab7511674f",
	"00000000-0000-0000-0000-000000000000",
	'transformOperation',
	'',
	'o_tfr = param.o_tfr;
obj = param.obj;

// create function object
create object instance op of Operation;
op.is_class_based = Scope::Class == o_tfr.Instance_Based;
relate op to obj across R416;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = "op_" + o_tfr.Name;
invocable.parent_name = op.class_name;
invocable.parent_package = op.class_package;
relate op to invocable across R427;

// link type
select one s_dt related by o_tfr->S_DT[R116];
type = UnresolvedType::getInstance( s_dt:s_dt );
relate type to invocable across R428;

// create parameters
select any o_tparm related by o_tfr->O_TPARM[R117];
prev_o_tparm = o_tparm;
// select first parameter
while ( not_empty prev_o_tparm )
  o_tparm = prev_o_tparm;
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
end while;
while ( not_empty o_tparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = o_tparm.Name;
  parm.by_ref = ( 1 == o_tparm.By_Ref );
  select one parm_dt related by o_tparm->S_DT[R118];
  parm_type = UnresolvedType::getInstance( s_dt:parm_dt );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("30ba3ab6-6d9c-4d33-bd48-006d0df3ab1c",
	"03e1ea6e-74af-412c-b034-76ab7511674f",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("36319cba-4224-4f29-ab04-3a8b3ee913a7",
	"03e1ea6e-74af-412c-b034-76ab7511674f",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"30ba3ab6-6d9c-4d33-bd48-006d0df3ab1c",
	'');
INSERT INTO PE_PE
	VALUES ("03e1ea6e-74af-412c-b034-76ab7511674f",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cae43083-b72d-40f8-95cb-4b31855ce3ee",
	"00000000-0000-0000-0000-000000000000",
	'transformInterface',
	'',
	'c_i = param.c_i;
select one ep_pkg related by c_i->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:c_i.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the interface package object
create object instance iface of Interface;
relate iface to file across R401;

// relate to the c_i
relate iface to c_i across R421;

// transform messages
select many c_eps related by c_i->C_EP[R4003];
for each c_ep in c_eps
  ::transformMessage( c_ep:c_ep, iface:iface );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("c871a7f5-dd47-49c0-ad37-2478c2c84f13",
	"cae43083-b72d-40f8-95cb-4b31855ce3ee",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("80698720-cc57-44ba-8aa5-600c524db338",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("cae43083-b72d-40f8-95cb-4b31855ce3ee",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e5071316-f813-44a9-b6f4-51f4e3089418",
	"00000000-0000-0000-0000-000000000000",
	'transformMessage',
	'',
	'c_ep = param.c_ep;
iface = param.iface;
select one c_as related by c_ep->C_AS[R4004];
select one c_io related by c_ep->C_IO[R4004];

if ( not_empty c_as )  // TODO currently only support signals

// create message object
create object instance msg of Message;
msg.to_provider = true;
if ( not_empty c_as )
  msg.to_provider = ( c_as.Direction == IFDirectionType::ClientServer );
elif ( not_empty c_io )
  msg.to_provider = ( c_io.Direction == IFDirectionType::ClientServer );
end if;
relate msg to iface across R419;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = c_ep.Name;
invocable.parent_name = msg.iface_name;
invocable.parent_package = msg.iface_package;
relate msg to invocable across R427;

// link type
select any s_dt from instances of S_DT where ( "void" == selected.Name );
type = UnresolvedType::getInstance( s_dt:s_dt );
relate type to invocable across R428;

// create parameters
select any c_pp related by c_ep->C_PP[R4006];
prev_c_pp = c_pp;
// select first parameter
while ( not_empty prev_c_pp )
  c_pp = prev_c_pp;
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
end while;
while ( not_empty c_pp )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = c_pp.Name;
  parm.by_ref = ( 1 == c_pp.By_Ref );
  select one parm_dt related by c_pp->S_DT[R4007];
  parm_type = UnresolvedType::getInstance( s_dt:parm_dt );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
end while;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("d7b9fb63-0ec0-4363-bf10-f8cee68b219b",
	"e5071316-f813-44a9-b6f4-51f4e3089418",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("773be1d9-8ccf-438c-a765-b071c635f13f",
	"e5071316-f813-44a9-b6f4-51f4e3089418",
	'iface',
	"fb653c16-f8e6-4951-9132-f0d7d0319578",
	0,
	'',
	"d7b9fb63-0ec0-4363-bf10-f8cee68b219b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fb653c16-f8e6-4951-9132-f0d7d0319578",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../architecture/interface/interface.xtuml');
INSERT INTO PE_PE
	VALUES ("e5071316-f813-44a9-b6f4-51f4e3089418",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("48a30c71-bd16-4087-a818-1c1479c64a33",
	"00000000-0000-0000-0000-000000000000",
	'transformPort',
	'',
	'c_po = param.c_po;
comp_def = param.comp_def;
select one c_c related by c_po->C_C[R4010];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:c_po.Name, start_lower:false );
file.path = ::c_cToPath( c_c:c_c );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = true; // TODO

// create the interface package object
create object instance port of Port;
relate port to file across R401;
relate port to c_po across R422;

// relate to other component
relate port to comp_def across R417;

// relate to iface if the iface is there
select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
select one iface related by c_i->Interface[R421];
if ( empty iface and not_empty c_i )
  ::transformInterface( c_i:c_i );
  select one iface related by c_i->Interface[R421];
end if;
if ( not_empty iface )
  relate port to iface across R418;
  select many msgs related by iface->Message[R419];
  for each msg in msgs
    create object instance port_msg of PortMessage;
    relate port to msg across R420 using port_msg;
  end for;
  select one iface_file related by iface->File[R401];
  ::addFileToImports( file:file, file_to_import:iface_file );
end if;

// add imports
::addStringToImports( file:file, s:"io.ciera.summit.interfaces.IMessage" );

// add to component file
select one component_file related by comp_def->File[R401];
//::addFileToImports( file:component_file, file_to_import:file );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4e27e7e4-b388-4b0c-93bb-d8ccf14f4478",
	"48a30c71-bd16-4087-a818-1c1479c64a33",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("751cc73a-dc3b-419c-b6dd-daba79556a01",
	"48a30c71-bd16-4087-a818-1c1479c64a33",
	'comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"4e27e7e4-b388-4b0c-93bb-d8ccf14f4478",
	'');
INSERT INTO PE_PE
	VALUES ("48a30c71-bd16-4087-a818-1c1479c64a33",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("65d02f39-685e-434b-971f-e57fb66067f8",
	"00000000-0000-0000-0000-000000000000",
	'transformAssociation',
	'',
	'r_rel = param.r_rel;
containing_comp_def = param.containing_comp_def;
select one file related by containing_comp_def->File[R401];
select one ep_pkg related by r_rel->PE_PE[R8001]->EP_PKG[R8000];

// create the relationship
create object instance rel of Relationship;
rel.name = "R" + STR::itoa( i:r_rel.Numb );
rel.num = r_rel.Numb;
create object instance ric of RelationshipInComponent;
relate rel to containing_comp_def across R448.''forms relationship population of'' using ric;

// create the relationsip subtype
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )

  // create the subtype
  create object instance binary of BinaryRelationship;
  relate binary to rel across R433;
  binary.one_phrase = "";
  binary.other_phrase = "";
  ric.relationship_type = 0;

  // set the extends class
  rel.extends = "BinaryRelationship";
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.BinaryRelationship" );
  
  // Link the ''one'' and ''other'' classes. If there is a R_FORM, it is considered
  // the ''one''. Otherwise, an arbitrary ''one'' and ''other'' are chosen
  select one r_form related by r_simp->R_FORM[R208];
  select one r_form_class related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  if ( not_empty r_form_class )
    select any r_part related by r_simp->R_PART[R207];
    select one r_part_class related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty r_part_class )
      // relate classes
      relate r_form_class to binary across R434.''one class for'';
      relate r_part_class to binary across R435.''other class for'';
      // add type imports
      select one form_type related by r_form_class->Type[R407];
      form_type.addToImports( file:file );
      select one part_tpye related by r_part_class->Type[R407];
      part_tpye.addToImports( file:file );
      // set phrases
      if ( "" != r_form.Txt_Phrs )
        binary.one_phrase = r_form.Txt_Phrs;
      end if;
      if ( "" != r_part.Txt_Phrs )
        binary.other_phrase = r_part.Txt_Phrs;
      end if;
      // set conditionalities and multiplicities
      if ( 0 == r_form.Cond )
        binary.one_conditionality = Cond::UNCONDITIONAL;
      else
        binary.one_conditionality = Cond::CONDITIONAL;
      end if;
      if ( 0 == r_form.Mult )
        binary.one_multiplicity = Mult::ONE;
      else
        binary.one_multiplicity = Mult::MANY;
      end if;
      if ( 0 == r_part.Cond )
        binary.other_conditionality = Cond::UNCONDITIONAL;
      else
        binary.other_conditionality = Cond::CONDITIONAL;
      end if;
      if ( 0 == r_part.Mult )
        binary.other_multiplicity = Mult::ONE;
      else
        binary.other_multiplicity = Mult::MANY;
      end if;
    else
      // TODO bad
    end if;
  else
    select any r_part1 related by r_simp->R_PART[R207];
    select one r_part1_class related by r_part1->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    select any r_part2 related by r_simp->R_PART[R207] where ( selected.OIR_ID != r_part1.OIR_ID );
    select one r_part2_class related by r_part2->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
    if ( not_empty r_part1_class and not_empty r_part2_class )
      // relate classes
      relate r_part1_class to binary across R434.''one class for'';
      relate r_part2_class to binary across R435.''other class for'';
      // add type imports
      select one part1_type related by r_part1_class->Type[R407];
      part1_type.addToImports( file:file );
      select one part2_type related by r_part2_class->Type[R407];
      part2_type.addToImports( file:file );
      // set phrases
      if ( "" != r_part1.Txt_Phrs )
        binary.one_phrase = r_part1.Txt_Phrs;
      end if;
      if ( "" != r_part2.Txt_Phrs )
        binary.other_phrase = r_part2.Txt_Phrs;
      end if;
      // set conditionalities and multiplicities
      if ( 0 == r_part1.Cond )
        binary.one_conditionality = Cond::UNCONDITIONAL;
      else
        binary.one_conditionality = Cond::CONDITIONAL;
      end if;
      if ( 0 == r_part1.Mult )
        binary.one_multiplicity = Mult::ONE;
      else
        binary.one_multiplicity = Mult::MANY;
      end if;
      if ( 0 == r_part2.Cond )
        binary.other_conditionality = Cond::UNCONDITIONAL;
      else
        binary.other_conditionality = Cond::CONDITIONAL;
      end if;
      if ( 0 == r_part2.Mult )
        binary.other_multiplicity = Mult::ONE;
      else
        binary.other_multiplicity = Mult::MANY;
      end if;
    else
      // TODO bad
    end if;
  end if;

else
select one r_subsup related by r_rel->R_SUBSUP[R206];
if ( not_empty r_subsup )
  
  // create the subtype
  create object instance subsup of SubsuperRelationship;
  relate subsup to rel across R433;
  ric.relationship_type = 2;

  // set the extends class
  rel.extends = "SubsuperRelationship";
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.SubsuperRelationship" );
  
  // link the ''super'' class
  select one r_super_class related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  if ( not_empty r_super_class )
    // relate classes
    relate r_super_class to subsup across R436.''supertype class for'';
    // add type imports
    select one super_type related by r_super_class->Type[R407];
    super_type.addToImports( file:file );
  else
    // TODO bad
  end if;
  
  // link all the ''sub'' classes
  select many r_sub_classes related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  if ( cardinality r_sub_classes > 0 )
    for each r_sub_class in r_sub_classes
      // relate classes
      create object instance class_as_sub of ClassAsSubtype;
      relate r_sub_class to subsup across R437.''subtype class for'' using class_as_sub;
      // add type imports
      select one sub_type related by r_super_class->Type[R407];
      sub_type.addToImports( file:file );
    end for;
  else
    // TODO bad
  end if;

else
select one r_assoc related by r_rel->R_ASSOC[R206];
if ( not_empty r_assoc )
  
  // create subtype
  create object instance assoc of AssociativeRelationship;
  relate assoc to rel across R433;
  assoc.one_phrase = "";
  assoc.other_phrase = "";
  ric.relationship_type = 1;

  // set the extends class
  rel.extends = "AssociativeRelationship";
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.AssociativeRelationship" );
  
  // link the ''one'', ''other'', and ''link'' classes
  select one r_aone related by r_assoc->R_AONE[R209];
  select one r_aone_class related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  select one r_aoth related by r_assoc->R_AOTH[R210];
  select one r_aoth_class related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  select one r_assr related by r_assoc->R_ASSR[R211];
  select one r_assr_class related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409.''is basis for''];
  if ( not_empty r_aone_class and not_empty r_aoth_class and not_empty r_assr_class )
    // relate classes
    relate r_aone_class to assoc across R438.''one class for'';
    relate r_aoth_class to assoc across R439.''other class for'';
    relate r_assr_class to assoc across R440.''link class for'';
    // add type imports
    select one aone_type related by r_aone_class->Type[R407];
    aone_type.addToImports( file:file );
    select one aoth_type related by r_aoth_class->Type[R407];
    aoth_type.addToImports( file:file );
    select one assr_type related by r_assr_class->Type[R407];
    assr_type.addToImports( file:file );
    // set phrases
    if ( "" != r_aone.Txt_Phrs )
      assoc.one_phrase = r_aone.Txt_Phrs;
    end if;
    if ( "" != r_aoth.Txt_Phrs )
      assoc.other_phrase = r_aoth.Txt_Phrs;
    end if;
    // set conditionalities and multiplicities
    if ( 0 == r_aone.Cond )
      assoc.one_conditionality = Cond::UNCONDITIONAL;
    else
      assoc.one_conditionality = Cond::CONDITIONAL;
    end if;
    if ( 0 == r_aone.Mult )
      assoc.one_multiplicity = Mult::ONE;
    else
      assoc.one_multiplicity = Mult::MANY;
    end if;
    if ( 0 == r_aoth.Cond )
      assoc.other_conditionality = Cond::UNCONDITIONAL;
    else
      assoc.other_conditionality = Cond::CONDITIONAL;
    end if;
    if ( 0 == r_aoth.Mult )
      assoc.other_multiplicity = Mult::ONE;
    else
      assoc.other_multiplicity = Mult::MANY;
    end if;
    if ( 0 == r_assr.Mult )
      assoc.link_multiplicity = Mult::ONE;
    else
      assoc.link_multiplicity = Mult::MANY;
    end if;
  else
    // TODO bad
  end if;

else
  // TODO bad
end if; end if; end if;

// add necessary imports
::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationshipSet" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.UniqueId" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException" );
if ( 0 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.BinaryRelationshipSet" );
elif ( 1 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.AssociativeRelationshipSet" );
elif ( 2 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.cairn.classes.SubsuperRelationshipSet" );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("b3c53e3f-1986-4e3c-8047-04a969a3dd54",
	"65d02f39-685e-434b-971f-e57fb66067f8",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("c4877261-9b00-4291-af18-5490a8b591b9",
	"65d02f39-685e-434b-971f-e57fb66067f8",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"b3c53e3f-1986-4e3c-8047-04a969a3dd54",
	'');
INSERT INTO PE_PE
	VALUES ("65d02f39-685e-434b-971f-e57fb66067f8",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("805f004a-96b0-4655-b033-f9311da42460",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectors',
	'',
	'obj = param.obj;

// transform selectors for binary associations
// one to other case
select many one_binary_rels related by obj->BinaryRelationship[R434.''one class for''];
for each one_binary_rel in one_binary_rels
  select one one_rel related by one_binary_rel->Relationship[R433];
  select one other_obj related by one_binary_rel->Class[R435.''has other''];
  ::transformSelector( obj:obj, target_class_name:one_binary_rel.other_class_name, rel_num:one_rel.num,
                       phrase:one_binary_rel.one_phrase, cond:one_binary_rel.other_conditionality,
                       mult:one_binary_rel.other_multiplicity, src_class:"one", dst_class:"other",
                       relationship_cast:"IBinaryRelationship", other_obj:other_obj );
end for;
// other to one case
select many other_binary_rels related by obj->BinaryRelationship[R435.''other class for''];
for each other_binary_rel in other_binary_rels
  select one other_rel related by other_binary_rel->Relationship[R433];
  select one one_obj related by other_binary_rel->Class[R434.''has one''];
  ::transformSelector( obj:obj, target_class_name:other_binary_rel.one_class_name, rel_num:other_rel.num,
                       phrase:other_binary_rel.other_phrase, cond:other_binary_rel.one_conditionality,
                       mult:other_binary_rel.one_multiplicity, src_class:"other", dst_class:"one",
                       relationship_cast:"IBinaryRelationship", other_obj:one_obj );
end for;

// transform selectors for linked associations
select many link_assoc_rels related by obj->AssociativeRelationship[R440.''link class for''];
for each link_assoc_rel in link_assoc_rels
  // link to one case
  select one link_rel related by link_assoc_rel->Relationship[R433];
  select one one_obj related by link_assoc_rel->Class[R438.''has one''];
  ::transformSelector( obj:obj, target_class_name:link_assoc_rel.one_class_name, rel_num:link_rel.num,
                       phrase:link_assoc_rel.other_phrase, cond:Cond::UNCONDITIONAL, mult:Mult::ONE,
                       src_class:"link", dst_class:"one", relationship_cast:"IAssociativeRelationship",
                       other_obj:one_obj );
  // link to other case
  select one other_obj related by link_assoc_rel->Class[R439.''has other''];
  ::transformSelector( obj:obj, target_class_name:link_assoc_rel.other_class_name, rel_num:link_rel.num,
                       phrase:link_assoc_rel.one_phrase, cond:Cond::UNCONDITIONAL, mult:Mult::ONE,
                       src_class:"link", dst_class:"other", relationship_cast:"IAssociativeRelationship",
                       other_obj:other_obj );
end for;
select many one_assoc_rels related by obj->AssociativeRelationship[R438.''one class for''];
for each one_assoc_rel in one_assoc_rels
  // one to other case
  select one one_rel related by one_assoc_rel->Relationship[R433];
  select one other_obj related by one_assoc_rel->Class[R439.''has other''];
  ::transformSelector( obj:obj, target_class_name:one_assoc_rel.other_class_name, rel_num:one_rel.num,
                       phrase:one_assoc_rel.one_phrase, cond:one_assoc_rel.other_conditionality,
                       mult:one_assoc_rel.other_multiplicity, src_class:"one", dst_class:"other",
                       relationship_cast:"IAssociativeRelationship", other_obj:other_obj );
  // one to link case
  select one link_obj related by one_assoc_rel->Class[R440.''has link''];
  link_mult = Mult::ONE;
  if ( Mult::MANY == one_assoc_rel.link_multiplicity or Mult::MANY == one_assoc_rel.other_multiplicity ) link_mult = Mult::MANY; end if;
  link_phrase = "";
  if ( obj.name == other_obj.name and obj.package == other_obj.package ) link_phrase = one_assoc_rel.one_phrase; end if;
  ::transformSelector( obj:obj, target_class_name:one_assoc_rel.link_class_name, rel_num:one_rel.num,
                       phrase:link_phrase, cond:one_assoc_rel.other_conditionality, mult:link_mult,
                       src_class:"one", dst_class:"link", relationship_cast:"IAssociativeRelationship",
                       other_obj:link_obj );
end for;
select many other_assoc_rels related by obj->AssociativeRelationship[R439.''other class for''];
for each other_assoc_rel in other_assoc_rels
  // other to one case
  select one other_rel related by other_assoc_rel->Relationship[R433];
  select one one_obj related by other_assoc_rel->Class[R438.''has one''];
  ::transformSelector( obj:obj, target_class_name:other_assoc_rel.one_class_name, rel_num:other_rel.num,
                       phrase:other_assoc_rel.other_phrase, cond:other_assoc_rel.one_conditionality,
                       mult:other_assoc_rel.one_multiplicity, src_class:"other", dst_class:"one",
                       relationship_cast:"IAssociativeRelationship", other_obj:one_obj );
  // other to link case
  select one link_obj related by other_assoc_rel->Class[R440.''has link''];
  link_mult = Mult::ONE;
  if ( Mult::MANY == other_assoc_rel.link_multiplicity or Mult::MANY == other_assoc_rel.one_multiplicity ) link_mult = Mult::MANY; end if;
  link_phrase = "";
  if ( obj.name == one_obj.name and obj.package == one_obj.package ) link_phrase = other_assoc_rel.other_phrase; end if;
  ::transformSelector( obj:obj, target_class_name:other_assoc_rel.link_class_name, rel_num:other_rel.num,
                       phrase:link_phrase, cond:other_assoc_rel.one_conditionality, mult:link_mult,
                       src_class:"other", dst_class:"link", relationship_cast:"IAssociativeRelationship",
                       other_obj:link_obj );
end for;

// transform selectors for subsuper associations
select many sub_subsuper_rels related by obj->ClassAsSubtype[R437]->SubsuperRelationship[R437.''subtype class for''];
for each sub_subsuper_rel in sub_subsuper_rels
  // sub to super case
  select one sub_rel related by sub_subsuper_rel->Relationship[R433];
  select one super_obj related by sub_subsuper_rel->Class[R436.''has supertype''];
  ::transformSelector( obj:obj, target_class_name:sub_subsuper_rel.supertype_class_name, rel_num:sub_rel.num,
                       phrase:"is a", cond:Cond::UNCONDITIONAL, mult: Mult::ONE, src_class:"subtype",
                       dst_class:"supertype", relationship_cast:"ISubsuperRelationship", other_obj:super_obj );
end for;
select many super_subsuper_rels related by obj->SubsuperRelationship[R436.''supertype class for''];
for each super_subsuper_rel in super_subsuper_rels
  // super to sub cases
  select one super_rel related by super_subsuper_rel->Relationship[R433];
  select many sub_objs related by super_subsuper_rel->ClassAsSubtype[R437]->Class[R437.''has subtype''];
  for each sub_obj in sub_objs
    ::transformSelector( obj:obj, target_class_name:sub_obj.name, rel_num:super_rel.num,
                         phrase:"is a", cond:Cond::UNCONDITIONAL, mult: Mult::ONE, src_class:"supertype",
                         dst_class:"subtype", relationship_cast:"ISubsuperRelationship", other_obj:sub_obj );
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("20d5b38b-69c9-4fdd-a4d2-5fddb7bcf9bd",
	"805f004a-96b0-4655-b033-f9311da42460",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("805f004a-96b0-4655-b033-f9311da42460",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("47432932-84af-42f4-8df8-1fefb66ca9b3",
	"00000000-0000-0000-0000-000000000000",
	'transformSelector',
	'',
	'obj = param.obj;
other_obj = param.other_obj;

// This function creates selectors for the class and set for a single path
// through a relationship. For single instances, a selectOne or selectAny and
// selectMany are created based on multiplicity. For sets, a selectAny and
// SelectMany are always created.

// create set selectors
select one obj_set related by obj->ClassSet[R406.''is type of single element in''];

// create ''any'' selector
name3 = "selectAny" + param.target_class_name;
if ( "" != param.phrase )
  name3 = name3 + "_" + T::underscore( s:param.phrase ) + "_" + obj.name;
end if;
name3 = name3 + "OnR" + STR::itoa( i:param.rel_num );
create object instance sel3 of Selector;
sel3.parent_name = obj_set.name;
sel3.parent_package = obj_set.package;
sel3.name = name3;
sel3.phrase = param.phrase;
sel3.multiplicity = param.mult;
sel3.returns_set = false;
create object instance set_sel3 of SetSelector;
relate set_sel3 to sel3 across R445;
relate set_sel3 to obj_set across R444.''navigates from'';

// link up type
select any s_irdt3 related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
select one s_dt3 related by s_irdt3->S_DT[R17];
if ( empty s_dt3 )
  // TODO bad
end if;
type3 = UnresolvedType::getInstance( s_dt:s_dt3 );
relate type3 to sel3 across R446.''shapes return of'';

// create ''many'' selector
name4 = "selectMany" + param.target_class_name;
if ( "" != param.phrase )
  name4 = name4 + "_" + T::underscore( s:param.phrase ) + "_" + obj.name;
end if;
name4 = name4 + "OnR" + STR::itoa( i:param.rel_num );
create object instance sel4 of Selector;
sel4.parent_name = obj_set.name;
sel4.parent_package = obj_set.package;
sel4.name = name4;
sel4.phrase = param.phrase;
sel4.multiplicity = param.mult;
sel4.returns_set = true;
create object instance set_sel4 of SetSelector;
relate set_sel4 to sel4 across R445;
relate set_sel4 to obj_set across R444.''navigates from'';

// link up type
select any s_irdt4 related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
select one s_dt4 related by s_irdt4->S_DT[R17];
if ( empty s_dt4 )
  // TODO bad
end if;
type4 = UnresolvedType::getInstance( s_dt:s_dt4 );
relate type4 to sel4 across R446.''shapes return of'';

// create the instance selectors
if ( Mult::ONE == param.mult )

  // create ''one'' selector
  name = "selectOne" + param.target_class_name;
  if ( "" != param.phrase )
    name = name + "_" + T::underscore( s:param.phrase ) + "_" + obj.name;
  end if;
  name = name + "OnR" + STR::itoa( i:param.rel_num );
  create object instance sel of Selector;
  sel.parent_name = obj.name;
  sel.parent_package = obj.package;
  sel.name = name;
  sel.phrase = param.phrase;
  sel.multiplicity = Mult::ONE;
  sel.returns_set = false;
  create object instance inst_sel of InstanceSelector;
  inst_sel.rel_num = param.rel_num;
  inst_sel.conditionality = param.cond;
  inst_sel.src_class = param.src_class;
  inst_sel.dst_class = param.dst_class;
  inst_sel.relationship_cast = param.relationship_cast;
  relate inst_sel to sel across R445;
  relate inst_sel to obj across R442.''navigates from'';
  relate inst_sel to set_sel3 across R4505.''invoked by'';
  relate inst_sel to set_sel4 across R4505.''invoked by'';

  // link up type
  select any s_irdt related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
  select one s_dt related by s_irdt->S_DT[R17];
  if ( empty s_dt )
    // TODO bad
  end if;
  type = UnresolvedType::getInstance( s_dt:s_dt );
  relate type to sel across R446.''shapes return of'';

else
  
  // create ''any'' selector
  name1 = "selectAny" + param.target_class_name;
  if ( "" != param.phrase )
    name1 = name1 + "_" + T::underscore( s:param.phrase ) + "_" + obj.name;
  end if;
  name1 = name1 + "OnR" + STR::itoa( i:param.rel_num );
  create object instance sel1 of Selector;
  sel1.parent_name = obj.name;
  sel1.parent_package = obj.package;
  sel1.name = name1;
  sel1.phrase = param.phrase;
  sel1.multiplicity = Mult::MANY;
  sel1.returns_set = false;
  create object instance inst_sel1 of InstanceSelector;
  inst_sel1.rel_num = param.rel_num;
  inst_sel1.conditionality = param.cond;
  inst_sel1.src_class = param.src_class;
  inst_sel1.dst_class = param.dst_class;
  inst_sel1.relationship_cast = param.relationship_cast;
  relate inst_sel1 to sel1 across R445;
  relate inst_sel1 to obj across R442.''navigates from'';
  relate inst_sel1 to set_sel3 across R4505.''invoked by'';

  // link up type
  select any s_irdt1 related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
  select one s_dt1 related by s_irdt1->S_DT[R17];
  if ( empty s_dt1 )
    // TODO bad
  end if;
  type1 = UnresolvedType::getInstance( s_dt:s_dt1 );
  relate type1 to sel1 across R446.''shapes return of'';

  // create ''many'' selector
  name2 = "selectMany" + param.target_class_name;
  if ( "" != param.phrase )
    name2 = name2 + "_" + T::underscore( s:param.phrase ) + "_" + obj.name;
  end if;
  name2 = name2 + "OnR" + STR::itoa( i:param.rel_num );
  create object instance sel2 of Selector;
  sel2.parent_name = obj.name;
  sel2.parent_package = obj.package;
  sel2.name = name2;
  sel2.phrase = param.phrase;
  sel2.multiplicity = Mult::MANY;
  sel2.returns_set = true;
  create object instance inst_sel2 of InstanceSelector;
  inst_sel2.rel_num = param.rel_num;
  inst_sel2.conditionality = param.cond;
  inst_sel2.src_class = param.src_class;
  inst_sel2.dst_class = param.dst_class;
  inst_sel2.relationship_cast = param.relationship_cast;
  relate inst_sel2 to sel2 across R445;
  relate inst_sel2 to obj across R442.''navigates from'';
  relate inst_sel2 to set_sel4 across R4505.''invoked by'';

  // link up type
  select any s_irdt2 related by other_obj->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( selected.isSet );
  select one s_dt2 related by s_irdt2->S_DT[R17];
  if ( empty s_dt2 )
    // TODO bad
  end if;
  type2 = UnresolvedType::getInstance( s_dt:s_dt2 );
  relate type2 to sel2 across R446.''shapes return of'';

end if;

// add imports to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"java.util.Set" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.XtumlException" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IWhere" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationship" );
::addStringToImports( file:file, s:"io.ciera.summit.classes.IModelInstance" );
if ( Cond::UNCONDITIONAL == param.cond or Mult::ONE == param.mult )
  ::addStringToImports( file:file, s:"io.ciera.summit.exceptions.ModelIntegrityException" );
end if;
if ( Mult::MANY == param.mult )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IRelationship" );
end if;
::addStringToImports( file:file, s:"io.ciera.summit.classes." + param.relationship_cast );
::addStringToImports( file:file, s:"io.ciera.summit.classes." + param.relationship_cast + "Set" );

// add imports to object set file
select one set_file related by obj_set->File[R401];
::addStringToImports( file:set_file, s:"io.ciera.summit.exceptions.XtumlException" );
::addStringToImports( file:set_file, s:"io.ciera.summit.classes.IWhere" );
::addStringToImports( file:set_file, s:"io.ciera.summit.classes.IModelInstance" );
::addStringToImports( file:set_file, s:"io.ciera.summit.classes.IEmptyInstance" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("b81cbde9-cf73-4bf5-b4f8-3eb2e2cc1593",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a36f73e6-39bf-4863-912d-294bd48d6003",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'target_class_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"b81cbde9-cf73-4bf5-b4f8-3eb2e2cc1593",
	'');
INSERT INTO S_SPARM
	VALUES ("f708f32f-8d0f-40ec-9cc7-0fd1733c8f48",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'rel_num',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"a36f73e6-39bf-4863-912d-294bd48d6003",
	'');
INSERT INTO S_SPARM
	VALUES ("0fc92035-82d5-4383-b4ae-026358c73fb5",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'phrase',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f708f32f-8d0f-40ec-9cc7-0fd1733c8f48",
	'');
INSERT INTO S_SPARM
	VALUES ("e4b07e41-5de1-453c-b389-7cab38261f79",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'cond',
	"a2a4c58a-abbb-4d3a-afee-8f80d4ab0cd4",
	0,
	'',
	"0fc92035-82d5-4383-b4ae-026358c73fb5",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a2a4c58a-abbb-4d3a-afee-8f80d4ab0cd4",
	"00000000-0000-0000-0000-000000000000",
	'Cond',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("1ac9195e-0a27-4cad-81de-677a96ff5688",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'mult',
	"8774ba5f-d952-424f-a26a-4815240d9ec8",
	0,
	'',
	"e4b07e41-5de1-453c-b389-7cab38261f79",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8774ba5f-d952-424f-a26a-4815240d9ec8",
	"00000000-0000-0000-0000-000000000000",
	'Mult',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("85857ae0-d439-4e33-b983-8e7ea2fa5d48",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'other_obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"97a8b201-770e-4c9c-bb31-e9ae2807ad04",
	'');
INSERT INTO S_SPARM
	VALUES ("97a8b201-770e-4c9c-bb31-e9ae2807ad04",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'relationship_cast',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"351a2fc2-3520-48b5-a8dc-3662662e5c19",
	'');
INSERT INTO S_SPARM
	VALUES ("265cd96c-63d3-444d-8d66-6ea14b9fe330",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'src_class',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"1ac9195e-0a27-4cad-81de-677a96ff5688",
	'');
INSERT INTO S_SPARM
	VALUES ("351a2fc2-3520-48b5-a8dc-3662662e5c19",
	"47432932-84af-42f4-8df8-1fefb66ca9b3",
	'dst_class',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"265cd96c-63d3-444d-8d66-6ea14b9fe330",
	'');
INSERT INTO PE_PE
	VALUES ("47432932-84af-42f4-8df8-1fefb66ca9b3",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	"00000000-0000-0000-0000-000000000000",
	'transformUtility',
	'',
	's_ee = param.s_ee;
ep_pkg = param.ep_pkg;
containing_comp_def = param.containing_comp_def;

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_ee.Key_Lett, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = param.exclude;

// create the utility object
create object instance utility of Utility;
relate utility to file across R401;

// relate the containing component
if ( not_empty containing_comp_def )
  relate utility to containing_comp_def across R4558.''may exist within context of'';
  select one component_file related by containing_comp_def->File[R401];
  ::addFileToImports( file:file, file_to_import:component_file );
else
  ::addStringToImports( file:file, s:"io.ciera.summit.components.IComponent" );
end if;

// relate the default implementation if it exists
select any default_utility from instances of Utility where ( selected.package == "io.ciera.cairn.util" and selected.name == "Default" + utility.name );
if ( not_empty default_utility )
  relate default_utility to utility across R4560.''provides default implementation for'';
  select one default_file related by default_utility->File[R401];
  ::addFileToImports( file:file, file_to_import:default_file );
end if;

// transform each utility function
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  ::transformUtilityFunction( s_brg:s_brg, utility:utility );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("3e2fdcea-3b0f-4b1e-9bc8-f44f1c434121",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	's_ee',
	"fc04695e-75c8-413e-a409-6dbc6465e011",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc04695e-75c8-413e-a409-6dbc6465e011",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<External Entity>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("2b01a5a1-1096-4eba-abb6-9c8d15e4bb40",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"17f7d23f-e0a1-41a5-9816-8fe56e4f9d41",
	'');
INSERT INTO S_SPARM
	VALUES ("42579ca2-d6b4-465a-8be0-bdfe32b0f0bc",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"2b01a5a1-1096-4eba-abb6-9c8d15e4bb40",
	'');
INSERT INTO S_SPARM
	VALUES ("17f7d23f-e0a1-41a5-9816-8fe56e4f9d41",
	"0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"3e2fdcea-3b0f-4b1e-9bc8-f44f1c434121",
	'');
INSERT INTO PE_PE
	VALUES ("0b1dcdfd-3e1a-4aaa-a22a-df354cd09e94",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9280b1e4-c562-48f3-8530-1ad3cee50c62",
	"00000000-0000-0000-0000-000000000000",
	'transformUtilityFunction',
	'',
	's_brg = param.s_brg;
utility = param.utility;

// create utility function object
create object instance util_func of UtilityFunction;
relate util_func to utility across R4559.''provided by'';

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_brg.Name;
invocable.parent_name = utility.name;
invocable.parent_package = utility.package;
relate util_func to invocable across R427;

// link type
select one s_dt related by s_brg->S_DT[R20];
type = UnresolvedType::getInstance( s_dt:s_dt );
relate type to invocable across R428;

// create parameters
select any s_bparm related by s_brg->S_BPARM[R21];
prev_s_bparm = s_bparm;
// select first parameter
while ( not_empty prev_s_bparm )
  s_bparm = prev_s_bparm;
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
end while;
while ( not_empty s_bparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = s_bparm.Name;
  parm.by_ref = ( 1 == s_bparm.By_Ref );
  select one parm_dt related by s_bparm->S_DT[R22];
  parm_type = UnresolvedType::getInstance( s_dt:parm_dt );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("7a55a482-325f-4c69-8b40-f5000de09729",
	"9280b1e4-c562-48f3-8530-1ad3cee50c62",
	'utility',
	"93db392d-1bd7-4276-baa0-47f361e867b5",
	0,
	'',
	"ea9b2942-b98d-4911-9a84-fb52e87ac401",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("93db392d-1bd7-4276-baa0-47f361e867b5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Utility>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO S_SPARM
	VALUES ("ea9b2942-b98d-4911-9a84-fb52e87ac401",
	"9280b1e4-c562-48f3-8530-1ad3cee50c62",
	's_brg',
	"ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("9280b1e4-c562-48f3-8530-1ad3cee50c62",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("95dbd48c-d367-4051-91dd-946f605e8a0b",
	"00000000-0000-0000-0000-000000000000",
	'transformBuiltinUtilities',
	'',
	'select any cairn from instances of S_SYS where ( selected.Name == "cairn" );
// select to io.ciera.cairn.util
select any io_pkg related by cairn->EP_PKG[R1401] where ( selected.Name == "io" );
select any ciera_pkg related by io_pkg->PE_PE[R8000]->EP_PKG[R8001] where ( selected.Name == "ciera" );
select any cairn_pkg related by ciera_pkg->PE_PE[R8000]->EP_PKG[R8001] where ( selected.Name == "cairn" );
select any util_pkg related by cairn_pkg->PE_PE[R8000]->EP_PKG[R8001] where ( selected.Name == "util" );
select many s_ees related by util_pkg->PE_PE[R8000]->S_EE[R8001];
for each s_ee in s_ees
  select any empty_comp_def from instances of ComponentDefinition where false;
  // modify the key letters of the EE
  s_ee.Key_Lett = "Default" + s_ee.Key_Lett;
  ::transformUtility( s_ee:s_ee, ep_pkg:util_pkg, containing_comp_def: empty_comp_def, exclude:true );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("95dbd48c-d367-4051-91dd-946f605e8a0b",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c8d55ce3-b33a-4e74-8624-a5b9cbf037da",
	"00000000-0000-0000-0000-000000000000",
	'transformInstanceLinkModifiers',
	'',
	'rel = param.rel;
containing_comp_def = param.containing_comp_def;
select any ric related by containing_comp_def->RelationshipInComponent[R448] where ( selected.relationship_name == rel.name );

// create the linker(s) and unlinker(s)
select one binary related by rel->BinaryRelationship[R433];
if ( not_empty binary )
  select one one_class related by binary->Class[R434.''has one''];
  select any one_cic related by one_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  select one other_class related by binary->Class[R435.''has other''];
  select any other_cic related by other_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  if ( not_empty one_cic and not_empty other_cic )
    // create relator
    create object instance ilm_relator of InstanceLinkModifier;
    ilm_relator.name = "relate" + one_class.name + "To" + other_class.name + "AcrossR" + STR::itoa( i:rel.num );
    relate ilm_relator to containing_comp_def across R4552.''instances linked in population of'';
    relate ilm_relator to ric across R4554.''modifies instances of'';
    create object instance relator of InstanceRelator;
    relate relator to ilm_relator across R4556;
    create object instance relator_param_one of ClassAsLinkParameter;
    relate ilm_relator to one_cic across R4555 using relator_param_one;
    if ( "" != binary.other_phrase ) relator_param_one.name = one_class.name + "_" + T::l( s:T::underscore( s:binary.other_phrase ) ) + "_" + other_class.name;
    else relator_param_one.name = T::l( s:one_class.name ); end if;
    relator_param_one.phrase = binary.other_phrase;
    create object instance relator_param_other of ClassAsLinkParameter;
    relate ilm_relator to other_cic across R4555 using relator_param_other;
    if ( "" != binary.one_phrase ) relator_param_other.name = other_class.name + "_" + T::l( s:T::underscore( s:binary.one_phrase ) ) + "_" + one_class.name;
    else relator_param_other.name = T::l( s:other_class.name ); end if;
    relator_param_other.phrase = binary.one_phrase;
    relate relator_param_other to relator_param_one across R4557.''follows'';
    // one case
    if ( Mult::ONE == binary.other_multiplicity )
      select any parm related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == one_class.name and
                                                                                                           selected.class_package == one_class.package and
                                                                                                           selected.phrase == binary.other_phrase );
      create object instance check of CardinalityCheck;
      check.participant = "one";
      check.relationship_set_cast = "IBinaryRelationshipSet";
      relate relator to check across R4562.''existing relationships checked by'';
      relate parm to check across R4563.''starting point for'';
    end if;
    // other case
    if ( Mult::ONE == binary.one_multiplicity )
      select any parm related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == other_class.name and
                                                                                                           selected.class_package == other_class.package and
                                                                                                           selected.phrase == binary.one_phrase );
      create object instance check of CardinalityCheck;
      check.participant = "other";
      check.relationship_set_cast = "IBinaryRelationshipSet";
      relate relator to check across R4562.''existing relationships checked by'';
      relate parm to check across R4563.''starting point for'';
    end if;
    // create unrelator
    create object instance ilm_unrelator of InstanceLinkModifier;
    ilm_unrelator.name = "unrelate" + one_class.name + "From" + other_class.name + "AcrossR" + STR::itoa( i:rel.num );
    relate ilm_unrelator to containing_comp_def across R4552.''instances linked in population of'';
    relate ilm_unrelator to ric across R4554.''modifies instances of'';
    create object instance unrelator of InstanceUnrelator;
    relate unrelator to ilm_unrelator across R4556;
    unrelator.relationship_set_cast = "IBinaryRelationshipSet";
    create object instance unrelator_param_one of ClassAsLinkParameter;
    relate ilm_unrelator to one_cic across R4555 using unrelator_param_one;
    if ( "" != binary.other_phrase ) unrelator_param_one.name = one_class.name + "_" + T::l( s:T::underscore( s:binary.other_phrase ) ) + "_" + other_class.name;
    else unrelator_param_one.name = T::l( s:one_class.name ); end if;
    unrelator_param_one.phrase = binary.other_phrase;
    create object instance unrelator_param_other of ClassAsLinkParameter;
    relate ilm_unrelator to other_cic across R4555 using unrelator_param_other;
    if ( "" != binary.one_phrase ) unrelator_param_other.name = other_class.name + "_" + T::l( s:T::underscore( s:binary.one_phrase ) ) + "_" + one_class.name;
    else unrelator_param_other.name = T::l( s:other_class.name ); end if;
    unrelator_param_other.phrase = binary.one_phrase;
    relate unrelator_param_other to unrelator_param_one across R4557.''follows'';
  else
    // TODO bad
  end if;
else
select one subsup related by rel->SubsuperRelationship[R433];
if ( not_empty subsup )
  select one super_class related by subsup->Class[R436.''has supertype''];
  select any super_cic related by super_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  select many sub_classes related by subsup->ClassAsSubtype[R437]->Class[R437.''has subtype''];
  for each sub_class in sub_classes
    select any sub_cic related by sub_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
    if ( not_empty super_cic and not_empty sub_cic )
      // create relator
      create object instance ilm_relator of InstanceLinkModifier;
      ilm_relator.name = "relate" + sub_class.name + "To" + super_class.name + "AcrossR" + STR::itoa( i:rel.num );
      relate ilm_relator to containing_comp_def across R4552.''instances linked in population of'';
      relate ilm_relator to ric across R4554.''modifies instances of'';
      create object instance relator of InstanceRelator;
      relate relator to ilm_relator across R4556;
      create object instance relator_param_sub of ClassAsLinkParameter;
      relate ilm_relator to sub_cic across R4555 using relator_param_sub;
      relator_param_sub.name = T::l( s:sub_class.name );
      relator_param_sub.phrase = "";
      create object instance relator_param_super of ClassAsLinkParameter;
      relate ilm_relator to super_cic across R4555 using relator_param_super;
      relator_param_super.name = T::l( s:super_class.name );
      relator_param_super.phrase = "";
      relate relator_param_super to relator_param_sub across R4557.''follows'';
      // super case
      select any parm1 related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == super_class.name and
                                                                                                            selected.class_package == super_class.package );
      create object instance check1 of CardinalityCheck;
      check1.participant = "supertype";
      check1.relationship_set_cast = "ISubsuperRelationshipSet";
      relate relator to check1 across R4562.''existing relationships checked by'';
      relate parm1 to check1 across R4563.''starting point for'';
      // sub case
      select any parm2 related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == sub_class.name and
                                                                                                            selected.class_package == sub_class.package );
      create object instance check2 of CardinalityCheck;
      check2.participant = "subtype";
      check2.relationship_set_cast = "ISubsuperRelationshipSet";
      relate relator to check2 across R4562.''existing relationships checked by'';
      relate parm2 to check2 across R4563.''starting point for'';
      // create unrelator
      create object instance ilm_unrelator of InstanceLinkModifier;
      ilm_unrelator.name = "unrelate" + sub_class.name + "From" + super_class.name + "AcrossR" + STR::itoa( i:rel.num );
      relate ilm_unrelator to containing_comp_def across R4552.''instances linked in population of'';
      relate ilm_unrelator to ric across R4554.''modifies instances of'';
      create object instance unrelator of InstanceUnrelator;
      relate unrelator to ilm_unrelator across R4556;
      unrelator.relationship_set_cast = "ISubsuperRelationshipSet";
      create object instance unrelator_param_sub of ClassAsLinkParameter;
      relate ilm_unrelator to sub_cic across R4555 using unrelator_param_sub;
      unrelator_param_sub.name = T::l( s:sub_class.name );
      unrelator_param_sub.phrase = "";
      create object instance unrelator_param_super of ClassAsLinkParameter;
      relate ilm_unrelator to super_cic across R4555 using unrelator_param_super;
      unrelator_param_super.name = T::l( s:super_class.name );
      unrelator_param_super.phrase = "";
      relate unrelator_param_super to unrelator_param_sub across R4557.''follows'';
    else
      // TODO bad
    end if;
  end for;
else
select one assoc related by rel->AssociativeRelationship[R433];
if ( not_empty assoc )
  select one one_class related by assoc->Class[R438.''has one''];
  select any one_cic related by one_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  select one other_class related by assoc->Class[R439.''has other''];
  select any other_cic related by other_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  select one link_class related by assoc->Class[R440.''has link''];
  select any link_cic related by link_class->ClassInComponent[R408] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  if ( not_empty one_cic and not_empty other_cic and not_empty link_cic )
    // create relator
    create object instance ilm_relator of InstanceLinkModifier;
    ilm_relator.name = "relate" + one_class.name + "To" + other_class.name + "AcrossR" + STR::itoa( i:rel.num ) + "Using" + link_class.name;
    relate ilm_relator to containing_comp_def across R4552.''instances linked in population of'';
    relate ilm_relator to ric across R4554.''modifies instances of'';
    create object instance relator of InstanceRelator;
    relate relator to ilm_relator across R4556;
    create object instance relator_param_one of ClassAsLinkParameter;
    relate ilm_relator to one_cic across R4555 using relator_param_one;
    if ( "" != assoc.other_phrase ) relator_param_one.name = one_class.name + "_" + T::l( s:T::underscore( s:assoc.other_phrase ) ) + "_" + other_class.name;
    else relator_param_one.name = T::l( s:one_class.name ); end if;
    relator_param_one.phrase = assoc.other_phrase;
    create object instance relator_param_other of ClassAsLinkParameter;
    relate ilm_relator to other_cic across R4555 using relator_param_other;
    if ( "" != assoc.one_phrase ) relator_param_other.name = other_class.name + "_" + T::l( s:T::underscore( s:assoc.one_phrase ) ) + "_" + one_class.name;
    else relator_param_other.name = T::l( s:other_class.name ); end if;
    relator_param_other.phrase = assoc.one_phrase;
    relate relator_param_other to relator_param_one across R4557.''follows'';
    create object instance relator_param_link of ClassAsLinkParameter;
    relate ilm_relator to link_cic across R4555 using relator_param_link;
    relator_param_link.name = T::l( s:link_class.name );
    relator_param_link.phrase = "";
    relate relator_param_link to relator_param_other across R4557.''follows'';
    // one case
    if ( Mult::ONE == assoc.other_multiplicity )
      select any parm related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == one_class.name and
                                                                                                           selected.class_package == one_class.package and
                                                                                                           selected.phrase == assoc.other_phrase );
      create object instance check of CardinalityCheck;
      check.participant = "one";
      check.relationship_set_cast = "IAssociativeRelationshipSet";
      relate relator to check across R4562.''existing relationships checked by'';
      relate parm to check across R4563.''starting point for'';
    end if;
    // other case
    if ( Mult::ONE == assoc.one_multiplicity )
      select any parm related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == other_class.name and
                                                                                                           selected.class_package == other_class.package and
                                                                                                           selected.phrase == assoc.one_phrase );
      create object instance check of CardinalityCheck;
      check.participant = "other";
      check.relationship_set_cast = "IAssociativeRelationshipSet";
      relate relator to check across R4562.''existing relationships checked by'';
      relate parm to check across R4563.''starting point for'';
    end if;
    // link case
    if ( Mult::ONE == assoc.other_multiplicity )
      select any parm related by relator->InstanceLinkModifier[R4556]->ClassAsLinkParameter[R4555] where ( selected.class_name == link_class.name and
                                                                                                           selected.class_package == link_class.package and
                                                                                                           selected.phrase == "" );
      create object instance check of CardinalityCheck;
      check.participant = "link";
      check.relationship_set_cast = "IAssociativeRelationshipSet";
      relate relator to check across R4562.''existing relationships checked by'';
      relate parm to check across R4563.''starting point for'';
    end if;
    // create unrelator
    create object instance ilm_unrelator of InstanceLinkModifier;
    ilm_unrelator.name = "unrelate" + one_class.name + "From" + other_class.name + "AcrossR" + STR::itoa( i:rel.num ) + "Using" + link_class.name;
    relate ilm_unrelator to containing_comp_def across R4552.''instances linked in population of'';
    relate ilm_unrelator to ric across R4554.''modifies instances of'';
    create object instance unrelator of InstanceUnrelator;
    relate unrelator to ilm_unrelator across R4556;
    unrelator.relationship_set_cast = "IAssociativeRelationshipSet";
    create object instance unrelator_param_one of ClassAsLinkParameter;
    relate ilm_unrelator to one_cic across R4555 using unrelator_param_one;
    if ( "" != assoc.other_phrase ) unrelator_param_one.name = one_class.name + "_" + T::l( s:T::underscore( s:assoc.other_phrase ) ) + "_" + other_class.name;
    else unrelator_param_one.name = T::l( s:one_class.name ); end if;
    unrelator_param_one.phrase = assoc.other_phrase;
    create object instance unrelator_param_other of ClassAsLinkParameter;
    relate ilm_unrelator to other_cic across R4555 using unrelator_param_other;
    if ( "" != assoc.one_phrase ) unrelator_param_other.name = other_class.name + "_" + T::l( s:T::underscore( s:assoc.one_phrase ) ) + "_" + one_class.name;
    else unrelator_param_other.name = T::l( s:other_class.name ); end if;
    unrelator_param_other.phrase = assoc.one_phrase;
    relate unrelator_param_other to unrelator_param_one across R4557.''follows'';
    create object instance unrelator_param_link of ClassAsLinkParameter;
    relate ilm_unrelator to link_cic across R4555 using unrelator_param_link;
    unrelator_param_link.name = T::l( s:link_class.name );
    unrelator_param_link.phrase = "";
    relate unrelator_param_link to unrelator_param_other across R4557.''follows'';
  else
    // TODO bad
  end if;
end if; end if; end if;


// add to the containing component imports
select one file related by containing_comp_def->File[R401];
::addStringToImports( file:file, s:"io.ciera.summit.classes.IEmptyInstance" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.BadArgumentException" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.EmptyInstanceException" );
::addStringToImports( file:file, s:"io.ciera.summit.exceptions.ModelIntegrityException" );
if ( 0 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IBinaryRelationshipSet" );
elif ( 1 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.IAssociativeRelationshipSet" );
elif ( 2 == ric.relationship_type )
  ::addStringToImports( file:file, s:"io.ciera.summit.classes.ISubsuperRelationshipSet" );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("684dcb9f-dbcf-4a04-b8cc-428485722b9d",
	"c8d55ce3-b33a-4e74-8624-a5b9cbf037da",
	'rel',
	"acea8715-3cc0-489c-a9e9-9521870ce9ab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("acea8715-3cc0-489c-a9e9-9521870ce9ab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relationship>',
	'',
	'',
	'../architecture/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("131970d6-e6b8-47d9-b99a-f20b0610bb37",
	"c8d55ce3-b33a-4e74-8624-a5b9cbf037da",
	'containing_comp_def',
	"1fef1559-c5b6-4eb7-a9c4-8b126b9b51a0",
	0,
	'',
	"684dcb9f-dbcf-4a04-b8cc-428485722b9d",
	'');
INSERT INTO PE_PE
	VALUES ("c8d55ce3-b33a-4e74-8624-a5b9cbf037da",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b36bee85-a614-4d69-9feb-cda336242c18",
	"00000000-0000-0000-0000-000000000000",
	'transformAttributeReferences',
	'',
	'obj = param.obj;
select many attrs related by obj->Attribute[R410.''data abstracted by''];
for each attr in attrs
  select many o_rtidas related by attr->O_ATTR[R414.''is transformed from'']->O_RATTR[R106]->O_REF[R108]->O_RTIDA[R111];
  for each o_rtida in o_rtidas
    select one r_rel related by o_rtida->R_RTO[R110]->R_OIR[R203]->R_REL[R201];
    select one referred_to_attr related by o_rtida->O_OIDA[R110]->O_ATTR[R105]->Attribute[R414.''is basis for''];
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb );

    // create attribute reference
    create object instance attr_ref of AttributeReference;
    relate attr to referred_to_attr across R4506.''has value provided by'' using attr_ref;
    relate relationship to attr_ref across R4511.''provides link for'';
    attr_ref.phrase = ::oirGetPhrase( r_oir_id:o_rtida.OIR_ID );
    
    // create attribute propagation
    select any accessor related by referred_to_attr->AttributeAccessor[R4510.''value accessed through''] where ( selected.accessor_type == AttributeAccessor::SETTER );
    select any irdt related by attr->Class[R410.''abstracts data for'']->O_OBJ[R409.''is transformed from'']->S_IRDT[R123] where ( not selected.isSet );
    select any selector related by irdt->S_DT[R17]->Type[R423.''is basis of'']->Selector[R446.''shapes return of'']->InstanceSelector[R445] where ( selected.class_name == referred_to_attr.class_name and
                                                                                                                                                selected.class_package == referred_to_attr.class_package and
                                                                                                                                                selected.rel_num == relationship.num and
                                                                                                                                                selected.phrase == attr_ref.phrase );
    create object instance propagation of AttributePropagation;
    relate accessor to propagation across R4507.''propagates values via'';
    relate selector to propagation across R4509.''provides instance for'';
    relate attr_ref to propagation across R4508.''specifies attribute for'';
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("305d84cf-5ace-4032-bde8-9f647e76e318",
	"b36bee85-a614-4d69-9feb-cda336242c18",
	'obj',
	"ac93823e-2644-440b-977c-1f4e8480ec59",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b36bee85-a614-4d69-9feb-cda336242c18",
	1,
	"06787f13-1c16-4275-879c-00bbeee7cb88",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("06787f13-1c16-4275-879c-00bbeee7cb88",
	1,
	"acef9848-aa6d-428b-9882-cc90deb0a54a",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("acef9848-aa6d-428b-9882-cc90deb0a54a",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	"aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'ciera',
	'',
	0,
	'../ciera.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("aa743d3c-66dc-49df-a19a-ffbadf9c9d1b",
	'ciera',
	1,
	'../../ciera.xtuml');
